# Analyzer, Validator, Builder を分けている理由

ReVIEW.Analyzer, ReVIEW.Validator, ReVIEW.Builder を3つに分けた理由について。
Ruby版の実装では、3つ分全ての機能がBuilderに集約されている。その結果として以下の問題がクリアできない。

## 各クラスのざっくりした説明

なお、後述の構文規則改善をしたら一部クラスは無くてもよくなるかもしれない。

### Analyzer とは

ASTの各ノードに意味付けを行う。

Analyzer で処理する前は //list[label][caption] については以下のような意味しか持たない。
"list というブロック構文で、引数としてlabelとcaptionが渡されている"
Analyzer で処理した後は以下のようになる。
"リストを表現するブロック構文で、labelというラベルとcaptionというキャプションを持つ"

さらに、@&lt;list>{label} も
"list というインライン構文で、labelというコンテンツを持つ"
が
"リストの参照を表すインライン構文で、labelという名前のリスト構文への参照を張りたい"
という意味だと解釈される。

### Validator

ASTがReVIEW文書として整合性を保っているかどうかをチェックする。
例えば以下の内容についてチェックを行い、エラーにする役割を持つ。

* 章の下に項がいきなり来ていないか(節のレベルを飛ばしている)
* 参照先が発見できない要素はないか
* ビルダが未サポートの構文規則が登場しないか

Validatorが仕事をするためには、Builderのインスタンスに未サポートかどうか聞かないといけないのでBuilderへの依存が発生する。

[reviewjs-prh](https://github.com/vvakame/reviewjs-prh)のように追加の日本語チェックなどを組み込むHookとしても機能する。

### Builder

Analyser, Validator が処理したデータを実際に各フォーマットへと変換する役割。
Builder での処理フェーズに入ったら基本的にはエラーは発生しない(といいな

## 入力したReVIEW文書がformalであるかinformalかがビルダ毎に違う

Ruby版では、@&lt;del>{} を使える出力フォーマットと使えない出力フォーマットが発生してしまっていた。
そのため、少なくともBuilderに渡す段階より前でformalかinformalかを判定できるようにしたかった。BuilderはformalなReVIEW文書を各種出力形式へ変換するためのものという位置づけ。
そうすると、各Builderがサポートするべき構文、未サポートの構文について自動的にリスト化できるようにもなるはず。

## ユーザの独自拡張のために

構文の追加を自由に行えるようにするために、3つ全てを拡張可能な設計にしたい。
何か構文を追加した時に、Builderの実装漏れを自動的に検知できるようにするために、AnalyzerとBuilderの分離が必要だった。

# 既存文法の問題点

Ruby版ReVIEWの構文には以下の問題がある。

## 文法ごとにルールが違う

要するに、一貫性がないため覚えにくいし、処理も複雑になる。
例えば、= と //list で名前の定義の仕方が違う。
@<hd>{hoge} で章を参照するには ={hoge} と書くのに対し、@&lt;list>{hoge} でリストを参照するには //list[hoge][fuga] とする必要がある。
また、listなどについても引数の1番目が名前であるというのは、listの実装がそうなっているから、という理由でしかなく、構文としてそれが強制されていない。
これについては、名前を宣言するための新しい書き方を設けたほうがよいと考えている。
例えば @list#hoge とか。

また、それに合わせて参照する時の構文も設けないといけない。
例えば  %list@hogeとか $list@hogeとか @[list|hoge]とか @list&lt;hoge>とか。

名前の付け方以外に、[] や {} 内部の意味付けは各構文毎の実装に依存している。
そのため、[] や {} の中にシンボルを書く場合でもそれぞれ書式が違う。例えば以下の通り。
={part|chapter|name} と @<kw>{part,パート} のような感じ。引数内部を配列として扱いたい場合にも統一された記法を提供したほうが良いのではないかと感じる。

## Ruby文化を引きずっていて冗長

@&lt;fn>{hoge} の &lt; > 部分は、Rubyの構文的に @fn はvalidなので避けた、という話を聞いた。
きちんとパーサを作って解釈すればホスト言語の影響は考慮しなくてよくなるので、単に@fn{hoge}と書けたほうが楽だ。
これについては旧構文と新構文両方サポートするのは全く難しくないので好きなほうで書けばよい。
