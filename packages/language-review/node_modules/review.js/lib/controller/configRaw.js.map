{"version":3,"file":"configRaw.js","sourceRoot":"","sources":["configRaw.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport { Book, Symbol, ProcessReport } from \"../model/compilerModel\";\nimport { Analyzer, AcceptableSyntaxes } from \"../parser/analyzer\";\nimport { Validator } from \"../parser/validator\";\nimport { Builder } from \"../builder/builder\";\n\n/**\n * コマンドライン引数を解釈した結果のオプション。\n */\nexport interface Options {\n    reviewfile?: string;\n    base?: string;\n}\n\n/**\n * コンパイル実行時の設定。\n * 本についての情報や処理実行時のプログラムの差し替え。\n */\nexport interface ConfigRaw {\n    // TODO めんどくさくてまだ書いてない要素がたくさんある\n\n    basePath?: string;\n\n    read?: (path: string) => Promise<string>;\n    write?: (path: string, data: string) => Promise<void>;\n\n    listener?: ConfigListener;\n\n    analyzer?: Analyzer;\n    validators?: Validator[];\n    builders?: Builder[]; // TODO buildersの存在チェック入れる\n\n    book: ConfigBook;\n}\n\nexport interface ConfigListener {\n    onAcceptables?: (acceptableSyntaxes: AcceptableSyntaxes) => any;\n    onSymbols?: (symbols: Symbol[]) => any;\n    onReports?: (reports: ProcessReport[]) => any;\n\n    onCompileSuccess?: (book: Book) => void;\n    onCompileFailed?: (book?: Book) => void;\n}\n\nexport interface ConfigBook {\n    predef?: ConfigChapter[];\n    contents: ConfigPartOrChapter[];\n    appendix?: ConfigChapter[];\n    postdef?: ConfigChapter[];\n}\n\nexport interface ConfigPartOrChapter {\n    // part or file or chapter のみ来る想定\n    part?: ConfigPart;\n    chapter?: ConfigChapter;\n    // file は chapter 表記の省略形\n    file?: string;\n}\n\nexport interface ConfigPart {\n    file: string;\n    chapters: ConfigChapter[];\n}\n\nexport interface ConfigChapter {\n    file: string;\n}\n\n/**\n * 生の設定ファイルでの本の構成情報を画一的なフォーマットに変換し保持するためのクラス。\n */\nexport class BookStructure {\n    // TODO コンストラクタ隠したい\n    constructor(public predef: ContentStructure[], public contents: ContentStructure[], public appendix: ContentStructure[], public postdef: ContentStructure[]) {\n        this.predef = this.predef || [];\n        this.contents = this.contents || [];\n        this.appendix = this.appendix || [];\n        this.postdef = this.postdef || [];\n    }\n\n    static createBook(config: ConfigBook) {\n        if (!config) {\n            return new BookStructure([], [], [], []);\n        }\n        let predef = (config.predef || (<any>config).PREDEF || []).map((v: any /* IConfigChapter */) => ContentStructure.createChapter(v));\n        let contents = (config.contents || (<any>config).CHAPS || []).map((v: any) => {\n            // value は string(YAML由来) か IConfigPartOrChapter\n            if (!v) {\n                return null;\n            }\n            if (typeof v === \"string\") {\n                // YAML由来\n                return ContentStructure.createChapter(v);\n            } else if (v.chapter) {\n                // IConfigPartOrChapter 由来\n                return ContentStructure.createChapter(v.chapter);\n            } else if (v.part) {\n                // IConfigPartOrChapter 由来\n                return ContentStructure.createPart(v.part);\n            } else if (typeof v.file === \"string\" && v.chapters) {\n                return ContentStructure.createPart(v);\n            } else if (typeof v.file === \"string\") {\n                // IConfigPartOrChapter 由来\n                return ContentStructure.createChapter(v);\n            } else if (typeof v === \"object\") {\n                // YAML由来\n                return ContentStructure.createPart({\n                    file: Object.keys(v)[0],\n                    chapters: v[Object.keys(v)[0]].map((c: any) => ({ file: c }))\n                });\n            } else {\n                return null;\n            }\n        });\n        let appendix = (config.appendix || (<any>config).APPENDIX || []).map((v: any /* IConfigChapter */) => ContentStructure.createChapter(v));\n        let postdef = (config.postdef || (<any>config).POSTDEF || []).map((v: any /* IConfigChapter */) => ContentStructure.createChapter(v));\n        return new BookStructure(predef, contents as any, appendix, postdef);\n    }\n}\n\n/**\n * 生の設定ファイルでの本の構成情報を画一的なフォーマットに変換し保持するためのクラス。\n */\nexport class ContentStructure {\n    private constructor(public part: ConfigPart | null, public chapter: ConfigChapter | null) {\n    }\n\n    static createChapter(value: string | ConfigChapter): ContentStructure | null {\n        if (typeof value === \"string\") {\n            return new ContentStructure(null, { file: value });\n        } else if (value && typeof value.file === \"string\") {\n            return new ContentStructure(null, value);\n        } else {\n            return null;\n        }\n    }\n\n    static createPart(part: ConfigPart): ContentStructure | null {\n        if (!part) {\n            return null;\n        }\n\n        let p: ConfigPart = {\n            file: part.file,\n            chapters: (part.chapters || []).map((c: any) => typeof c === \"string\" ? { file: c } : c)\n        };\n        return new ContentStructure(p, null);\n    }\n}\n"]}