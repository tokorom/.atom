"use strict";
var PEG = require("../../resources/grammar");
var compilerModel_1 = require("../model/compilerModel");
var parser_1 = require("../parser/parser");
var config_1 = require("./config");
var configRaw_1 = require("./configRaw");
var parser_2 = require("../parser/parser");
var preprocessor_1 = require("../parser/preprocessor");
var textBuilder_1 = require("../builder/textBuilder");
var htmlBuilder_1 = require("../builder/htmlBuilder");
var walker_1 = require("../parser/walker");
var utils_1 = require("../utils/utils");
/**
 * ReVIEW文書を処理するためのコントローラ。
 * 処理の起点。
 */
var Controller = (function () {
    function Controller(options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        this.builders = { TextBuilder: textBuilder_1.TextBuilder, HtmlBuilder: htmlBuilder_1.HtmlBuilder };
    }
    /**
     * 設定の初期化を行う。
     * 通常、 ReVIEW.start 経由で呼び出される。
     * @param data
     */
    Controller.prototype.initConfig = function (data) {
        if (utils_1.isNodeJS()) {
            this.config = new config_1.NodeJSConfig(this.options, data);
        }
        else {
            this.config = new config_1.WebBrowserConfig(this.options, data);
        }
    };
    Controller.prototype.process = function () {
        var _this = this;
        return Promise.resolve(new compilerModel_1.Book(this.config))
            .then(function (book) { return _this.acceptableSyntaxes(book); })
            .then(function (book) { return _this.toContentChunk(book); })
            .then(function (book) { return _this.readReVIEWFiles(book); })
            .then(function (book) { return _this.parseContent(book); })
            .then(function (book) { return _this.preprocessContent(book); })
            .then(function (book) { return _this.processContent(book); })
            .then(function (book) { return _this.writeContent(book); })
            .then(function (book) { return _this.compileFinished(book); })
            .catch(function (err) { return _this.handleError(err); });
    };
    Controller.prototype.acceptableSyntaxes = function (book) {
        book.acceptableSyntaxes = book.config.analyzer.getAcceptableSyntaxes();
        if (book.config.listener.onAcceptables(book.acceptableSyntaxes) === false) {
            // false が帰ってきたら処理を中断する (undefined でも継続)
            book.config.listener.onCompileFailed();
            return Promise.reject(null);
        }
        return Promise.resolve(book);
    };
    Controller.prototype.toContentChunk = function (book) {
        var convert = function (c, parent) {
            var chunk = null;
            if (c.part) {
                chunk = new compilerModel_1.ContentChunk(book, c.part.file);
                c.part.chapters.forEach(function (c) {
                    convert(configRaw_1.ContentStructure.createChapter(c), chunk);
                });
            }
            else if (c.chapter) {
                chunk = new compilerModel_1.ContentChunk(book, parent, c.chapter.file);
            }
            else {
                return null;
            }
            if (parent) {
                parent.nodes.push(chunk);
            }
            return chunk;
        };
        book.predef = this.config.book.predef.map(function (c) { return convert(c); });
        book.contents = this.config.book.contents.map(function (c) { return convert(c); });
        book.appendix = this.config.book.appendix.map(function (c) { return convert(c); });
        book.postdef = this.config.book.postdef.map(function (c) { return convert(c); });
        return book;
    };
    Controller.prototype.readReVIEWFiles = function (book) {
        var promises = [];
        var read = function (chunk) {
            var resolvedPath = book.config.resolvePath(chunk.name);
            promises.push(book.config.read(resolvedPath).then(function (input) { return chunk.input = input; }));
            chunk.nodes.forEach(function (chunk) { return read(chunk); });
        };
        book.predef.forEach(function (chunk) { return read(chunk); });
        book.contents.forEach(function (chunk) { return read(chunk); });
        book.appendix.forEach(function (chunk) { return read(chunk); });
        book.postdef.forEach(function (chunk) { return read(chunk); });
        return Promise.all(promises).then(function () { return book; });
    };
    Controller.prototype.parseContent = function (book) {
        var _parse = function (chunk) {
            try {
                chunk.tree = parser_2.parse(chunk.input);
            }
            catch (e) {
                if (!(e instanceof PEG.SyntaxError)) {
                    throw e;
                }
                var se = e;
                var errorNode = new parser_1.SyntaxTree({
                    syntax: se.name,
                    location: {
                        start: {
                            line: se.line,
                            column: se.column,
                            offset: se.offset
                        },
                        end: void 0,
                    }
                });
                chunk.tree = { ast: errorNode, cst: null }; // TODO null! をやめる
            }
            chunk.nodes.forEach(function (chunk) { return _parse(chunk); });
        };
        book.predef.forEach(function (chunk) { return _parse(chunk); });
        book.contents.forEach(function (chunk) { return _parse(chunk); });
        book.appendix.forEach(function (chunk) { return _parse(chunk); });
        book.predef.forEach(function (chunk) { return _parse(chunk); });
        return book;
    };
    Controller.prototype.preprocessContent = function (book) {
        // Chapterに採番を行う
        var numberingChapter = function (chunk, counter) {
            // TODO partにも分け隔てなく採番してるけど間違ってるっしょ
            var chapters = [];
            walker_1.visit(chunk.tree.ast, {
                visitDefaultPre: function (_node) {
                },
                visitChapterPre: function (node) {
                    chapters.push(node);
                }
            });
            var max = 0;
            var currentLevel = 1;
            chapters.forEach(function (chapter) {
                var level = chapter.headline.level;
                max = Math.max(max, level);
                var i;
                if (currentLevel > level) {
                    for (i = level + 1; i <= max; i++) {
                        counter[i] = 0;
                    }
                }
                else if (currentLevel < level) {
                    for (i = level; i <= max; i++) {
                        counter[i] = 0;
                    }
                }
                currentLevel = level;
                counter[level] = (counter[level] || 0) + 1;
                chapter.no = counter[level];
            });
            chunk.no = counter[1];
            chunk.nodes.forEach(function (chunk) { return numberingChapter(chunk, counter); });
        };
        var numberingChapters = function (chunks, counter) {
            if (counter === void 0) { counter = {}; }
            chunks.forEach(function (chunk) { return numberingChapter(chunk, counter); });
        };
        numberingChapters(book.predef);
        numberingChapters(book.contents);
        numberingChapters(book.appendix);
        numberingChapters(book.postdef);
        var preprocessor = new preprocessor_1.SyntaxPreprocessor();
        preprocessor.start(book);
        return book;
    };
    Controller.prototype.processContent = function (book) {
        var _this = this;
        book.config.validators.forEach(function (validator) {
            validator.start(book, book.acceptableSyntaxes, _this.config.builders);
        });
        if (book.reports.some(function (report) { return report.level === compilerModel_1.ReportLevel.Error; })) {
            // エラーがあったら処理中断
            return Promise.resolve(book);
        }
        var symbols = book.allChunks.reduce(function (p, c) { return p.concat(c.process.symbols); }, []);
        if (this.config.listener.onSymbols(symbols) === false) {
            // false が帰ってきたら処理を中断する (undefined でも継続)
            return Promise.resolve(book);
        }
        return Promise.all(this.config.builders.map(function (builder) { return builder.init(book); })).then(function () { return book; });
    };
    Controller.prototype.writeContent = function (book) {
        var _this = this;
        var promises = [];
        var write = function (chunk) {
            chunk.builderProcesses.forEach(function (process) {
                var baseName = chunk.name.substr(0, chunk.name.lastIndexOf(".re"));
                var fileName = baseName + "." + process.builder.extention;
                promises.push(_this.config.write(fileName, process.result));
            });
            chunk.nodes.forEach(function (chunk) { return write(chunk); });
        };
        book.predef.forEach(function (chunk) { return write(chunk); });
        book.contents.forEach(function (chunk) { return write(chunk); });
        book.appendix.forEach(function (chunk) { return write(chunk); });
        book.postdef.forEach(function (chunk) { return write(chunk); });
        return Promise.all(promises).then(function () { return book; });
    };
    Controller.prototype.compileFinished = function (book) {
        book.config.listener.onReports(book.reports);
        if (!book.hasError) {
            book.config.listener.onCompileSuccess(book);
        }
        else {
            book.config.listener.onCompileFailed(book);
        }
        return book;
    };
    Controller.prototype.handleError = function (err) {
        // TODO 指定された .re が存在しない場合ここにくる…
        console.error("unexpected error", err);
        if (err && err.stack) {
            console.error(err.stack);
        }
        return Promise.reject(err);
    };
    return Controller;
}());
exports.Controller = Controller;
//# sourceMappingURL=controller.js.map