"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var builder_1 = require("../builder/builder");
var configRaw_1 = require("./configRaw");
var compilerModel_1 = require("../model/compilerModel");
var analyzer_1 = require("../parser/analyzer");
var validator_1 = require("../parser/validator");
var utils_1 = require("../utils/utils");
var Config = (function () {
    function Config(original) {
        this.original = original;
    }
    Object.defineProperty(Config.prototype, "read", {
        get: function () {
            throw new Error("please implements this method");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "write", {
        get: function () {
            throw new Error("please implements this method");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "exists", {
        get: function () {
            throw new Error("please implements this method");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "analyzer", {
        get: function () {
            return this.original.analyzer || new analyzer_1.DefaultAnalyzer();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "validators", {
        get: function () {
            var config = this.original;
            if (!config.validators || config.validators.length === 0) {
                return [new validator_1.DefaultValidator()];
            }
            else if (!Array.isArray(config.validators)) {
                return [config.validators];
            }
            else {
                return config.validators;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "builders", {
        get: function () {
            if (this._builders) {
                return this._builders;
            }
            var config = this.original;
            if (!config.builders || config.builders.length === 0) {
                // TODO DefaultBuilder は微妙感
                this._builders = [new builder_1.DefaultBuilder()];
            }
            else if (!Array.isArray(config.builders)) {
                this._builders = [config.builders];
            }
            else {
                this._builders = config.builders;
            }
            return this._builders;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "listener", {
        get: function () {
            throw new Error("please implements this method");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "book", {
        get: function () {
            if (!this._bookStructure) {
                this._bookStructure = configRaw_1.BookStructure.createBook(this.original.book);
            }
            return this._bookStructure;
        },
        enumerable: true,
        configurable: true
    });
    Config.prototype.resolvePath = function (_path) {
        throw new Error("please implements this method");
    };
    return Config;
}());
exports.Config = Config;
var NodeJSConfig = (function (_super) {
    __extends(NodeJSConfig, _super);
    function NodeJSConfig(options, original) {
        _super.call(this, original);
        this.options = options;
        this.original = original;
    }
    Object.defineProperty(NodeJSConfig.prototype, "read", {
        get: function () {
            return this.original.read || utils_1.IO.read;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeJSConfig.prototype, "write", {
        get: function () {
            return this.original.write || utils_1.IO.write;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeJSConfig.prototype, "exists", {
        get: function () {
            var _this = this;
            return function (path) {
                /* tslint:disable:no-require-imports */
                var fs = require("fs");
                var _path = require("path");
                /* tslint:enable:no-require-imports */
                var basePath = _this.original.basePath || __dirname;
                var promise = new Promise(function (resolve) {
                    fs.exists(_path.resolve(basePath, path), function (result) {
                        resolve({ path: path, result: result });
                    });
                });
                return promise;
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeJSConfig.prototype, "listener", {
        get: function () {
            if (this._listener) {
                return this._listener;
            }
            var listener = this.original.listener || {};
            listener.onAcceptables = listener.onAcceptables || (function () {
            });
            listener.onSymbols = listener.onSymbols || (function () {
            });
            listener.onReports = listener.onReports || this.onReports;
            listener.onCompileSuccess = listener.onCompileSuccess || this.onCompileSuccess;
            listener.onCompileFailed = listener.onCompileFailed || this.onCompileFailed;
            this._listener = listener;
            return this._listener;
        },
        enumerable: true,
        configurable: true
    });
    NodeJSConfig.prototype.onReports = function (reports) {
        /* tslint:disable:no-require-imports */
        var colors = require("colors");
        /* tslint:enable:no-require-imports */
        colors.setTheme({
            info: "cyan",
            warn: "yellow",
            error: "red"
        });
        reports.forEach(function (report) {
            var message = "";
            if (report.chapter) {
                message += report.chapter.name + " ";
            }
            if (report.nodes) {
                report.nodes.forEach(function (node) {
                    message += "[" + node.location.start.line + "," + node.location.start.column + "] ";
                });
            }
            message += report.message;
            if (report.level === compilerModel_1.ReportLevel.Error) {
                console.warn(message.error);
            }
            else if (report.level === compilerModel_1.ReportLevel.Warning) {
                console.error(message.warn);
            }
            else if (report.level === compilerModel_1.ReportLevel.Info) {
                console.info(message.info);
            }
            else {
                throw new Error("unknown report level.");
            }
        });
    };
    NodeJSConfig.prototype.onCompileSuccess = function (_book) {
        process.exit(0);
    };
    NodeJSConfig.prototype.onCompileFailed = function () {
        process.exit(1);
    };
    NodeJSConfig.prototype.resolvePath = function (path) {
        /* tslint:disable:no-require-imports */
        var p = require("path");
        /* tslint:enable:no-require-imports */
        var base = this.options.base || "./";
        return p.join(base, path);
    };
    return NodeJSConfig;
}(Config));
exports.NodeJSConfig = NodeJSConfig;
var WebBrowserConfig = (function (_super) {
    __extends(WebBrowserConfig, _super);
    function WebBrowserConfig(options, original) {
        _super.call(this, original);
        this.options = options;
        this.original = original;
    }
    Object.defineProperty(WebBrowserConfig.prototype, "read", {
        get: function () {
            return this.original.read || (function () {
                throw new Error("please implement config.read method");
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebBrowserConfig.prototype, "write", {
        get: function () {
            return this.original.write || (function () {
                throw new Error("please implement config.write method");
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebBrowserConfig.prototype, "exists", {
        get: function () {
            var _this = this;
            return function (path) {
                if (window.location.protocol === "file:") {
                    return _this._existsFileScheme(path);
                }
                else {
                    return _this._existsHttpScheme(path);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    WebBrowserConfig.prototype._existsFileScheme = function (_path) {
        var promise = new Promise(function (resolve) {
            var canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 14;
            var ctx = canvas.getContext("2d");
            ctx.fillText("file://では画像の存在チェックができません", 2, 10);
            var dataUrl = canvas.toDataURL();
            resolve({ path: dataUrl, result: true });
        });
        return promise;
    };
    WebBrowserConfig.prototype._existsHttpScheme = function (path) {
        var promise = new Promise(function (resolve) {
            try {
                var xhr_1 = new XMLHttpRequest();
                xhr_1.onreadystatechange = function () {
                    if (xhr_1.readyState === 4) {
                        if (xhr_1.status === 200 || xhr_1.status === 304) {
                            resolve({ path: path, result: true });
                        }
                        else {
                            resolve({ path: path, result: false });
                        }
                    }
                };
                xhr_1.open("GET", path);
                // If-Modified-Since をDate.now()で送って304返して貰ったほうが効率が良いのでは という発想
                xhr_1.setRequestHeader("If-Modified-Since", new Date().toUTCString());
                xhr_1.send();
            }
            catch (e) {
                if (e instanceof DOMException) {
                    var de = e;
                    console.log(de.message);
                }
                resolve({ path: path, result: false });
            }
        });
        return promise;
    };
    Object.defineProperty(WebBrowserConfig.prototype, "listener", {
        get: function () {
            if (this._listener) {
                return this._listener;
            }
            var listener = this.original.listener || {};
            listener.onAcceptables = listener.onAcceptables || (function () {
            });
            listener.onSymbols = listener.onSymbols || (function () {
            });
            listener.onReports = listener.onReports || this.onReports;
            listener.onCompileSuccess = listener.onCompileSuccess || this.onCompileSuccess;
            listener.onCompileFailed = listener.onCompileFailed || this.onCompileFailed;
            this._listener = listener;
            return this._listener;
        },
        enumerable: true,
        configurable: true
    });
    WebBrowserConfig.prototype.onReports = function (reports) {
        reports.forEach(function (report) {
            var message = "";
            if (report.chapter) {
                message += report.chapter.name + " ";
            }
            if (report.nodes) {
                report.nodes.forEach(function (node) {
                    message += "[" + node.location.start.line + "," + node.location.start.column + "] ";
                });
            }
            message += report.message;
            if (report.level === compilerModel_1.ReportLevel.Error) {
                console.warn(message);
            }
            else if (report.level === compilerModel_1.ReportLevel.Warning) {
                console.error(message);
            }
            else if (report.level === compilerModel_1.ReportLevel.Info) {
                console.info(message);
            }
            else {
                throw new Error("unknown report level.");
            }
        });
    };
    WebBrowserConfig.prototype.onCompileSuccess = function (_book) {
    };
    WebBrowserConfig.prototype.onCompileFailed = function (_book) {
    };
    WebBrowserConfig.prototype.resolvePath = function (path) {
        if (!this.options.base) {
            return path;
        }
        var base = this.options.base;
        if (!this.endWith(base, "/") && !this.startWith(path, "/")) {
            base += "/";
        }
        return base + path;
    };
    WebBrowserConfig.prototype.startWith = function (str, target) {
        return str.indexOf(target) === 0;
    };
    WebBrowserConfig.prototype.endWith = function (str, target) {
        return str.indexOf(target, str.length - target.length) !== -1;
    };
    return WebBrowserConfig;
}(Config));
exports.WebBrowserConfig = WebBrowserConfig;
//# sourceMappingURL=config.js.map