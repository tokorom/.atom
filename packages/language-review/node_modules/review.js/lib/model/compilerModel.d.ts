import { ConcreatSyntaxTree, NodeLocation, SyntaxTree, InlineElementSyntaxTree, BlockElementSyntaxTree } from "../parser/parser";
import { AcceptableSyntaxes } from "../parser/analyzer";
import { Builder } from "../builder/builder";
import { Config } from "../controller/config";
/**
 * 参照先についての情報。
 */
export interface ReferenceTo {
    part?: ContentChunk | null;
    partName: string;
    chapter?: ContentChunk | null;
    chapterName: string;
    targetSymbol: string;
    label: string;
    referenceNode?: SyntaxTree;
}
/**
 * シンボルについての情報。
 */
export interface Symbol {
    part?: ContentChunk;
    chapter?: ContentChunk | null;
    symbolName: string;
    labelName?: string;
    referenceTo?: ReferenceTo | null;
    node: SyntaxTree;
}
/**
 * 処理時に発生したレポートのレベル。
 */
export declare enum ReportLevel {
    Info = 0,
    Warning = 1,
    Error = 2,
}
/**
 * 処理時に発生したレポート。
 */
export declare class ProcessReport {
    level: ReportLevel;
    part: ContentChunk | null;
    chapter: ContentChunk | null;
    message: string;
    nodes: NodeLocation[];
    constructor(level: ReportLevel, part: ContentChunk | null, chapter: ContentChunk | null, message: string, nodes?: NodeLocation[]);
}
/**
 * コンパイル処理時の出力ハンドリング。
 */
export declare class BookProcess {
    reports: ProcessReport[];
    info(message: string): void;
    warn(message: string): void;
    error(message: string): void;
}
/**
 * コンパイル処理時の出力ハンドリング。
 */
export declare class Process {
    part: ContentChunk;
    chapter: ContentChunk | null;
    input: string | null;
    symbols: Symbol[];
    indexCounter: {
        [kind: string]: number;
    };
    afterProcess: Function[];
    private _reports;
    constructor(part: ContentChunk, chapter: ContentChunk | null, input: string | null);
    info(message: string, ...nodes: NodeLocation[]): void;
    warn(message: string, ...nodes: NodeLocation[]): void;
    error(message: string, ...nodes: NodeLocation[]): void;
    nextIndex(kind: string): number;
    readonly reports: ProcessReport[];
    addSymbol(symbol: Symbol): void;
    readonly missingSymbols: Symbol[];
    constructReferenceTo(node: InlineElementSyntaxTree, value: string, targetSymbol?: string, separator?: string): ReferenceTo | null;
    constructReferenceTo(node: BlockElementSyntaxTree, value: string, targetSymbol: string, separator?: string): ReferenceTo | null;
    addAfterProcess(func: Function): void;
    doAfterProcess(): void;
}
export declare class BuilderProcess {
    builder: Builder;
    base: Process;
    constructor(builder: Builder, base: Process);
    readonly info: (message: string, ...nodes: SyntaxTree[]) => void;
    readonly warn: (message: string, ...nodes: SyntaxTree[]) => void;
    readonly error: (message: string, ...nodes: SyntaxTree[]) => void;
    result: string;
    out(data: any): BuilderProcess;
    outRaw(data: any): BuilderProcess;
    pushOut(data: string): BuilderProcess;
    readonly input: string | null;
    readonly symbols: Symbol[];
    findChapter(chapId: string): ContentChunk;
    /**
     * 指定されたidの画像を探す。
     * 解決ルールは https://github.com/kmuto/review/wiki/ImagePath の通り。
     * Config側で絶対パス化やリソースの差し替えを行う可能性があるため、このメソッドの返り値は無加工で使うこと。
     * @param id
     * @returns {Promise<string>}
     */
    findImageFile(id: string): Promise<string>;
}
/**
 * 本全体を表す。
 */
export declare class Book {
    config: Config;
    process: BookProcess;
    acceptableSyntaxes: AcceptableSyntaxes;
    predef: ContentChunk[];
    contents: ContentChunk[];
    appendix: ContentChunk[];
    postdef: ContentChunk[];
    constructor(config: Config);
    readonly allChunks: ContentChunk[];
    readonly reports: ProcessReport[];
    readonly hasError: boolean;
    readonly hasWarning: boolean;
}
export declare class ContentChunk {
    book: Book;
    parent: ContentChunk;
    nodes: ContentChunk[];
    no: number;
    name: string;
    _input: string;
    tree: {
        ast: SyntaxTree;
        cst: ConcreatSyntaxTree;
    };
    process: Process;
    builderProcesses: BuilderProcess[];
    constructor(book: Book, parent: ContentChunk | null, name: string);
    constructor(book: Book, name: string);
    input: string;
    createBuilderProcess(builder: Builder): BuilderProcess;
    findResultByBuilder(builderName: string): string;
    findResultByBuilder(builder: Builder): string;
}
