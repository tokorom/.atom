// parser/ と builder/ で共用するモデル
"use strict";
var i18n_1 = require("../i18n/i18n");
var walker_1 = require("../parser/walker");
/**
 * 処理時に発生したレポートのレベル。
 */
(function (ReportLevel) {
    ReportLevel[ReportLevel["Info"] = 0] = "Info";
    ReportLevel[ReportLevel["Warning"] = 1] = "Warning";
    ReportLevel[ReportLevel["Error"] = 2] = "Error";
})(exports.ReportLevel || (exports.ReportLevel = {}));
var ReportLevel = exports.ReportLevel;
/**
 * 処理時に発生したレポート。
 */
var ProcessReport = (function () {
    function ProcessReport(level, part, chapter, message, nodes) {
        if (nodes === void 0) { nodes = []; }
        this.level = level;
        this.part = part;
        this.chapter = chapter;
        this.message = message;
        this.nodes = nodes;
    }
    return ProcessReport;
}());
exports.ProcessReport = ProcessReport;
/**
 * コンパイル処理時の出力ハンドリング。
 */
var BookProcess = (function () {
    function BookProcess() {
        this.reports = [];
    }
    BookProcess.prototype.info = function (message) {
        this.reports.push(new ProcessReport(ReportLevel.Info, null, null, message));
    };
    BookProcess.prototype.warn = function (message) {
        this.reports.push(new ProcessReport(ReportLevel.Warning, null, null, message));
    };
    BookProcess.prototype.error = function (message) {
        this.reports.push(new ProcessReport(ReportLevel.Error, null, null, message));
    };
    return BookProcess;
}());
exports.BookProcess = BookProcess;
/**
 * コンパイル処理時の出力ハンドリング。
 */
var Process = (function () {
    function Process(part, chapter, input) {
        this.part = part;
        this.chapter = chapter;
        this.input = input;
        this.symbols = [];
        this.indexCounter = {};
        this.afterProcess = [];
        this._reports = [];
    }
    Process.prototype.info = function (message) {
        var nodes = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            nodes[_i - 1] = arguments[_i];
        }
        this._reports.push(new ProcessReport(ReportLevel.Info, this.part, this.chapter, message, nodes));
    };
    Process.prototype.warn = function (message) {
        var nodes = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            nodes[_i - 1] = arguments[_i];
        }
        this._reports.push(new ProcessReport(ReportLevel.Warning, this.part, this.chapter, message, nodes));
    };
    Process.prototype.error = function (message) {
        var nodes = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            nodes[_i - 1] = arguments[_i];
        }
        this._reports.push(new ProcessReport(ReportLevel.Error, this.part, this.chapter, message, nodes));
    };
    Process.prototype.nextIndex = function (kind) {
        var nextIndex = this.indexCounter[kind];
        if (typeof nextIndex === "undefined") {
            nextIndex = 1;
        }
        else {
            nextIndex++;
        }
        this.indexCounter[kind] = nextIndex;
        return nextIndex;
    };
    Object.defineProperty(Process.prototype, "reports", {
        get: function () {
            return this._reports.sort(function (a, b) {
                if (a.nodes.length === 0 && b.nodes.length === 0) {
                    return 0;
                }
                else if (a.nodes.length === 0) {
                    return -1;
                }
                else if (b.nodes.length === 0) {
                    return 1;
                }
                else {
                    return a.nodes[0].location.start.offset - b.nodes[0].location.start.offset;
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Process.prototype.addSymbol = function (symbol) {
        symbol.part = this.part;
        symbol.chapter = this.chapter;
        this.symbols.push(symbol);
    };
    Object.defineProperty(Process.prototype, "missingSymbols", {
        get: function () {
            var result = [];
            this.symbols.forEach(function (symbol) {
                if (symbol.referenceTo && !symbol.referenceTo.referenceNode) {
                    result.push(symbol);
                }
            });
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Process.prototype.constructReferenceTo = function (node, value, targetSymbol, separator) {
        if (targetSymbol === void 0) { targetSymbol = node.symbol; }
        if (separator === void 0) { separator = "|"; }
        var splitted = value.split(separator);
        if (splitted.length === 3) {
            return {
                partName: splitted[0],
                chapterName: splitted[1],
                targetSymbol: targetSymbol,
                label: splitted[2]
            };
        }
        else if (splitted.length === 2) {
            return {
                part: this.part,
                partName: (this.part || {}).name,
                chapterName: splitted[0],
                targetSymbol: targetSymbol,
                label: splitted[1]
            };
        }
        else if (splitted.length === 1) {
            return {
                part: this.part,
                partName: (this.part || {}).name,
                chapter: this.chapter,
                chapterName: (this.chapter || {}).name,
                targetSymbol: targetSymbol,
                label: splitted[0]
            };
        }
        else {
            var message = i18n_1.t("compile.args_length_mismatch", "1 or 2 or 3", splitted.length);
            this.error(message, node);
            return null;
        }
    };
    Process.prototype.addAfterProcess = function (func) {
        this.afterProcess.push(func);
    };
    Process.prototype.doAfterProcess = function () {
        this.afterProcess.forEach(function (func) { return func(); });
        this.afterProcess = [];
    };
    return Process;
}());
exports.Process = Process;
var BuilderProcess = (function () {
    function BuilderProcess(builder, base) {
        this.builder = builder;
        this.base = base;
        this.result = "";
    }
    Object.defineProperty(BuilderProcess.prototype, "info", {
        get: function () {
            return this.base.info.bind(this.base);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BuilderProcess.prototype, "warn", {
        get: function () {
            return this.base.warn.bind(this.base);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BuilderProcess.prototype, "error", {
        get: function () {
            return this.base.error.bind(this.base);
        },
        enumerable: true,
        configurable: true
    });
    BuilderProcess.prototype.out = function (data) {
        // 最近のブラウザだと単純結合がアホみたいに早いらしいので
        this.result += this.builder.escape(data);
        return this;
    };
    BuilderProcess.prototype.outRaw = function (data) {
        // 最近のブラウザだと単純結合がアホみたいに早いらしいので
        this.result += data;
        return this;
    };
    // TODO pushOut いみふ感高いのでやめよう 削除だ！
    BuilderProcess.prototype.pushOut = function (data) {
        this.result = data + this.result;
        return this;
    };
    Object.defineProperty(BuilderProcess.prototype, "input", {
        get: function () {
            return this.base.input;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BuilderProcess.prototype, "symbols", {
        get: function () {
            return this.base.symbols;
        },
        enumerable: true,
        configurable: true
    });
    BuilderProcess.prototype.findChapter = function (chapId) {
        var book = this.base.chapter.book;
        var chaps = book.allChunks.filter(function (chunk) {
            var name = chunk.name.substr(0, chunk.name.lastIndexOf(".re"));
            if (name === chapId) {
                return true;
            }
            var chapter = null;
            walker_1.visit(chunk.tree.ast, {
                visitDefaultPre: function (_node, _parent) {
                    return !chapter;
                },
                visitChapterPre: function (node, _parent) {
                    chapter = node;
                    return false;
                }
            });
            if (chapter && chapter.headline.label) {
                return chapter.headline.label.arg === chapId;
            }
            return false;
        });
        return chaps[0];
    };
    /**
     * 指定されたidの画像を探す。
     * 解決ルールは https://github.com/kmuto/review/wiki/ImagePath の通り。
     * Config側で絶対パス化やリソースの差し替えを行う可能性があるため、このメソッドの返り値は無加工で使うこと。
     * @param id
     * @returns {Promise<string>}
     */
    BuilderProcess.prototype.findImageFile = function (id) {
        // NOTE: https://github.com/kmuto/review/wiki/ImagePath
        // 4軸マトリクス 画像dir, ビルダ有無, chapId位置, 拡張子
        var _this = this;
        var config = (this.base.part || this.base.chapter).book.config;
        var fileNameList = [];
        (function () {
            var imageDirList = ["images/"];
            var builderList = [_this.builder.extention + "/", ""];
            var chapSwitchList = [true, false];
            var chunkName = (_this.base.chapter || _this.base.part).name; // TODO もっと頭良い感じに
            chunkName = chunkName.substring(0, chunkName.lastIndexOf("."));
            var chapSeparatorList = ["/", "-"];
            var extList = ["png", "jpg", "jpeg", "gif"];
            imageDirList.forEach(function (imageDir) {
                builderList.forEach(function (builder) {
                    chapSwitchList.forEach(function (chapSwitch) {
                        chapSeparatorList.forEach(function (chapSeparator) {
                            extList.forEach(function (ext) {
                                var fileName = "";
                                fileName += imageDir;
                                fileName += builder;
                                if (chapSwitch) {
                                    fileName += chunkName;
                                    fileName += chapSeparator;
                                }
                                fileName += id + "." + ext;
                                if (fileNameList.indexOf(fileName) === -1) {
                                    fileNameList.push(fileName);
                                }
                            });
                        });
                    });
                });
            });
        })();
        var promise = new Promise(function (resolve, reject) {
            var checkFileExists = function () {
                if (fileNameList.length === 0) {
                    reject(id);
                    return;
                }
                var fileName = fileNameList.shift();
                config.exists(fileName).then(function (result) {
                    if (result.result) {
                        resolve(result.path);
                        return;
                    }
                    checkFileExists();
                });
            };
            checkFileExists();
        });
        return promise;
    };
    return BuilderProcess;
}());
exports.BuilderProcess = BuilderProcess;
/**
 * 本全体を表す。
 */
var Book = (function () {
    function Book(config) {
        this.config = config;
        this.process = new BookProcess();
        this.predef = [];
        this.contents = [];
        this.appendix = [];
        this.postdef = [];
    }
    Object.defineProperty(Book.prototype, "allChunks", {
        get: function () {
            var tmpArray = [];
            var add = function (chunk) {
                tmpArray.push(chunk);
                chunk.nodes.forEach(function (chunk) { return add(chunk); });
            };
            this.predef.forEach(function (chunk) { return add(chunk); });
            this.contents.forEach(function (chunk) { return add(chunk); });
            this.appendix.forEach(function (chunk) { return add(chunk); });
            this.postdef.forEach(function (chunk) { return add(chunk); });
            return tmpArray;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Book.prototype, "reports", {
        get: function () {
            var results = [];
            results = results.concat(this.process.reports);
            var gatherReports = function (chunk) {
                results = results.concat(chunk.process.reports);
                chunk.nodes.forEach(function (chunk) { return gatherReports(chunk); });
            };
            this.predef.forEach(function (chunk) { return gatherReports(chunk); });
            this.contents.forEach(function (chunk) { return gatherReports(chunk); });
            this.appendix.forEach(function (chunk) { return gatherReports(chunk); });
            this.postdef.forEach(function (chunk) { return gatherReports(chunk); });
            return results;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Book.prototype, "hasError", {
        get: function () {
            return this.reports.some(function (report) { return report.level === ReportLevel.Error; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Book.prototype, "hasWarning", {
        get: function () {
            return this.reports.some(function (report) { return report.level === ReportLevel.Warning; });
        },
        enumerable: true,
        configurable: true
    });
    return Book;
}());
exports.Book = Book;
var ContentChunk = (function () {
    function ContentChunk(book, parent, name) {
        this.book = book;
        this.nodes = [];
        this.builderProcesses = [];
        if (parent instanceof ContentChunk) {
            this.parent = parent;
            this.name = name;
        }
        else if (typeof name === "string") {
            this.name = name;
        }
        else {
            this.name = parent;
        }
        var part = parent ? parent : null;
        var chapter = this; // TODO thisがpartでchapterが無しの場合もあるよ…！！
        this.process = new Process(part, chapter, null);
    }
    Object.defineProperty(ContentChunk.prototype, "input", {
        get: function () {
            return this._input;
        },
        set: function (value) {
            // TODO やめる
            this._input = value;
            this.process.input = value;
        },
        enumerable: true,
        configurable: true
    });
    ContentChunk.prototype.createBuilderProcess = function (builder) {
        var builderProcess = new BuilderProcess(builder, this.process);
        this.builderProcesses.push(builderProcess);
        return builderProcess;
    };
    ContentChunk.prototype.findResultByBuilder = function (builder) {
        var founds;
        if (typeof builder === "string") {
            founds = this.builderProcesses.filter(function (process) { return process.builder.name === builder; });
        }
        else {
            founds = this.builderProcesses.filter(function (process) { return process.builder === builder; });
        }
        // TODO 何かエラー投げたほうがいい気もするなー
        return founds[0].result;
    };
    return ContentChunk;
}());
exports.ContentChunk = ContentChunk;
//# sourceMappingURL=compilerModel.js.map