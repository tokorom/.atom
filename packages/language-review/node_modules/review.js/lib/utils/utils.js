"use strict";
var compilerModel_1 = require("../model/compilerModel");
var parser_1 = require("../parser/parser");
var textBuilder_1 = require("../builder/textBuilder");
var htmlBuilder_1 = require("../builder/htmlBuilder");
var analyzer_1 = require("../parser/analyzer");
var validator_1 = require("../parser/validator");
var walker_1 = require("../parser/walker");
var index_1 = require("../index");
false && compilerModel_1.Book; // tslint消し
/**
 * ブラウザ上での実行かどうかを判別する。
 * @returns {boolean}
 */
function isBrowser() {
    "use strict";
    return typeof window !== "undefined";
}
exports.isBrowser = isBrowser;
/**
 * Node.js上での実行かどうかを判別する。
 * @returns {boolean}
 */
function isNodeJS() {
    "use strict";
    if (typeof atom !== "undefined") {
        // atomはNode.jsと判定したいけどwindowあるしbrowserify環境下と区別するために特別扱いする
        return true;
    }
    return !isBrowser() && !isAMD() && typeof exports === "object";
}
exports.isNodeJS = isNodeJS;
/**
 * AMD環境下での実行かどうかを判別する。
 * @returns {boolean|any}
 */
function isAMD() {
    "use strict";
    return typeof define === "function" && define.amd;
}
exports.isAMD = isAMD;
/**
 * ネストしたArrayを潰して平らにする。
 * Arrayかどうかの判定は Array.isArray を利用。
 * @param data
 * @returns {*[]}
 */
function flatten(data) {
    "use strict";
    if (data.some(function (d) { return Array.isArray(d); })) {
        return flatten(data.reduce(function (p, c) { return p.concat(c); }, []));
    }
    else {
        return data;
    }
}
exports.flatten = flatten;
function nodeToString(process, node) {
    "use strict";
    return process.input.substring(node.location.start.offset, node.location.end.offset);
}
exports.nodeToString = nodeToString;
function nodeContentToString(process, node) {
    "use strict";
    var minPos = Number.MAX_VALUE;
    var maxPos = -1;
    // child
    var childVisitor = {
        visitDefaultPre: function (node) {
            minPos = Math.min(minPos, node.location.start.offset);
            maxPos = Math.max(maxPos, node.location.end.offset);
        }
    };
    // root (子要素だけ抽出したい)
    walker_1.visit(node, {
        visitDefaultPre: function (_node) {
        },
        visitNodePre: function (node) {
            // Chapter, Inline, Block もここに来る
            node.childNodes.forEach(function (child) { return walker_1.visit(child, childVisitor); });
            return false;
        },
        visitHeadlinePre: function (node) {
            walker_1.visit(node.caption, childVisitor);
            return false;
        },
        visitUlistPre: function (node) {
            walker_1.visit(node.text, childVisitor);
            return false;
        },
        visitDlistPre: function (node) {
            walker_1.visit(node.text, childVisitor);
            walker_1.visit(node.content, childVisitor);
            return false;
        },
        visitOlistPre: function (node) {
            walker_1.visit(node.text, childVisitor);
            return false;
        },
        visitTextPre: function (_text) {
            walker_1.visit(node, childVisitor);
            return false;
        }
    });
    if (maxPos < 0) {
        return "";
    }
    else {
        return process.input.substring(minPos, maxPos);
    }
}
exports.nodeContentToString = nodeContentToString;
/**
 * 渡した要素から一番近いマッチする要素を探して返す。
 * 見つからなかった場合 null を返す。
 * @param node
 * @param predicate
 * @returns {SyntaxTree}
 */
function findUp(node, predicate) {
    "use strict";
    var result = null;
    walker_1.walk(node, function (node) {
        if (predicate(node)) {
            result = node;
            return null;
        }
        return node.parentNode;
    });
    return result;
}
exports.findUp = findUp;
/**
 * 渡した要素から直近のChapterを探して返す。
 * 見つからなかった場合 null を返す。
 * もし、渡した要素自身がChapterだった場合、自身を返すのでnode.parentNode を渡すこと。
 * @param node
 * @param level 探すChapterのlevel
 * @returns {ReVIEW.Parse.ChapterSyntaxTree}
 */
function findChapter(node, level) {
    "use strict";
    var chapter = null;
    walker_1.walk(node, function (node) {
        if (node instanceof parser_1.ChapterSyntaxTree) {
            chapter = node;
            if (typeof level === "undefined" || node.level === level) {
                return null;
            }
        }
        return node.parentNode;
    });
    return chapter;
}
exports.findChapter = findChapter;
function findChapterOrColumn(node, level) {
    "use strict";
    var chapter = null;
    var column = null;
    walker_1.walk(node, function (node) {
        if (node instanceof parser_1.ChapterSyntaxTree) {
            chapter = node;
            if (typeof level === "undefined" || node.level === level) {
                return null;
            }
        }
        else if (node instanceof parser_1.ColumnSyntaxTree) {
            column = node;
            if (typeof level === "undefined" || node.level === level) {
                return null;
            }
        }
        return node.parentNode;
    });
    return chapter || column;
}
exports.findChapterOrColumn = findChapterOrColumn;
function target2builder(target) {
    "use strict";
    // TODO 適当になおす…
    var builderName = target.charAt(0).toUpperCase() + target.substring(1) + "Builder";
    if (builderName === "TextBuilder") {
        return new textBuilder_1.TextBuilder();
    }
    if (builderName === "HtmlBuilder") {
        return new htmlBuilder_1.HtmlBuilder();
    }
    /*
    for (let name in ReVIEW.Build) {
        if (name === builderName) {
            let ctor = (<any>ReVIEW.Build)[name];
            return new ctor();
        }
    }
     */
    return null;
}
exports.target2builder = target2builder;
/**
 * Node.jsでのIOをざっくり行うためのモジュール。
 */
var IO;
(function (IO) {
    "use strict";
    /**
     * 指定されたファイルを読み文字列として返す。
     * @param path
     * @returns {*}
     */
    function read(path) {
        /* tslint:disable:no-require-imports */
        var fs = require("fs");
        /* tslint:enable:no-require-imports */
        return new Promise(function (resolve, reject) {
            fs.readFile(path, { encoding: "utf8" }, function (err, data) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(data);
                }
            });
        });
    }
    IO.read = read;
    /**
     * 指定されたファイルへ文字列を書く。
     * @param path
     * @param content
     */
    function write(path, content) {
        /* tslint:disable:no-require-imports */
        var fs = require("fs");
        /* tslint:enable:no-require-imports */
        return new Promise(function (resolve, reject) {
            fs.writeFile(path, content, function (err) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(null);
                }
            });
        });
    }
    IO.write = write;
})(IO = exports.IO || (exports.IO = {}));
/**
 * 行数から桁数の変換 100行 -> 3桁
 */
function linesToFigure(lines) {
    "use strict";
    return String(lines).length;
}
exports.linesToFigure = linesToFigure;
function padLeft(str, pad, maxLength) {
    "use strict";
    if (maxLength <= str.length) {
        return str;
    }
    return stringRepeat(maxLength - str.length, pad) + str;
}
exports.padLeft = padLeft;
function stringRepeat(times, src) {
    "use strict";
    return new Array(times + 1).join(src);
}
exports.stringRepeat = stringRepeat;
/**
 * 実行するためのヘルパクラス群
 */
var Exec;
(function (Exec) {
    "use strict";
    function singleCompile(input, fileName, target, tmpConfig /* ReVIEW.IConfig */) {
        "use strict";
        var config = tmpConfig || {};
        config.read = config.read || (function () { return Promise.resolve(input); });
        config.analyzer = config.analyzer || new analyzer_1.DefaultAnalyzer();
        config.validators = config.validators || [new validator_1.DefaultValidator()];
        if (target && target2builder(target) == null) {
            console.error(target + " is not exists in builder");
            process.exit(1);
        }
        config.builders = config.builders;
        if (!config.builders) {
            if (target) {
                var builder = target2builder(target);
                if (!builder) {
                    return Promise.reject("unknown target: " + target);
                }
                config.builders = [builder];
            }
            else {
                config.builders = [new textBuilder_1.TextBuilder()];
            }
        }
        config.book = config.book || {
            contents: [
                { file: fileName }
            ]
        };
        config.book.contents = config.book.contents || [
            { file: fileName }
        ];
        var results = {};
        config.write = config.write || (function (path, content) { return results[path] = content; });
        config.listener = config.listener || {
            onReports: function () {
            },
            onCompileSuccess: function () {
            },
            onCompileFailed: function () {
            }
        };
        config.listener.onReports = config.listener.onReports || (function () {
        });
        config.listener.onCompileSuccess = config.listener.onCompileSuccess || (function () {
        });
        config.listener.onCompileFailed = config.listener.onCompileFailed || (function () {
        });
        var success;
        var originalCompileSuccess = config.listener.onCompileSuccess;
        config.listener.onCompileSuccess = function (book) {
            success = true;
            originalCompileSuccess(book);
        };
        var originalCompileFailed = config.listener.onCompileFailed;
        config.listener.onCompileFailed = function (book) {
            success = false;
            originalCompileFailed(book);
        };
        return index_1.start(function (review) {
            review.initConfig(config);
        })
            .then(function (book) {
            return {
                book: book,
                results: results
            };
        });
    }
    Exec.singleCompile = singleCompile;
})(Exec = exports.Exec || (exports.Exec = {}));
//# sourceMappingURL=utils.js.map