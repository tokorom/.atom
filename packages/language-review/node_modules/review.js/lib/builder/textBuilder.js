"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var builder_1 = require("./builder");
var i18n_1 = require("../i18n/i18n");
var parser_1 = require("../parser/parser");
var walker_1 = require("../parser/walker");
var utils_1 = require("../utils/utils");
var TextBuilder = (function (_super) {
    __extends(TextBuilder, _super);
    function TextBuilder() {
        _super.apply(this, arguments);
        this.extention = "txt";
    }
    TextBuilder.prototype.escape = function (data) {
        return data;
    };
    TextBuilder.prototype.headlinePre = function (process, _name, node) {
        // TODO no の採番がレベル別になっていない
        // TODO 2.3.2 みたいな階層を返せるメソッドが何かほしい
        process.out("■H").out(node.level).out("■");
        if (node.level === 1) {
            var text = i18n_1.t("builder.chapter", node.parentNode.no);
            process.out(text).out("　");
        }
        else if (node.level === 2) {
        }
    };
    TextBuilder.prototype.headlinePost = function (process, _name, _node) {
        process.out("\n\n");
    };
    TextBuilder.prototype.columnHeadlinePre = function (process, node) {
        process.out("\n◆→開始:コラム←◆\n");
        process.out("■");
        return function (v) {
            walker_1.visit(node.caption, v);
        };
    };
    TextBuilder.prototype.columnHeadlinePost = function (process, _node) {
        process.out("\n");
    };
    TextBuilder.prototype.columnPost = function (process, _node) {
        process.out("◆→終了:コラム←◆\n\n");
    };
    TextBuilder.prototype.paragraphPost = function (process, _name, _node) {
        process.out("\n");
    };
    TextBuilder.prototype.ulistPre = function (process, _name, node) {
        this.ulistParentHelper(process, node, function () {
            process.out("\n\n●\t");
        });
        if (node.parentNode instanceof parser_1.UlistElementSyntaxTree && node.prev instanceof parser_1.UlistElementSyntaxTree === false) {
            process.out("\n\n");
        }
        else if (node.parentNode instanceof parser_1.UlistElementSyntaxTree) {
            process.out("");
        }
        process.out("●\t");
    };
    TextBuilder.prototype.ulistPost = function (process, _name, _node) {
        process.out("\n");
    };
    TextBuilder.prototype.olistPre = function (process, _name, node) {
        process.out(node.no).out("\t");
    };
    TextBuilder.prototype.olistPost = function (process, _name, _node) {
        process.out("\n");
    };
    TextBuilder.prototype.dlistPre = function (process, _name, node) {
        return function (v) {
            process.out("★");
            walker_1.visit(node.text, v);
            process.out("☆\n");
            process.out("\t");
            walker_1.visit(node.content, v);
            process.out("\n");
        };
    };
    TextBuilder.prototype.dlistPost = function (process, _name, _node) {
        process.out("\n");
    };
    TextBuilder.prototype.block_list_pre = function (process, node) {
        process.out("◆→開始:リスト←◆\n");
        var chapter = utils_1.findChapter(node, 1);
        if (!chapter) {
            process.error(i18n_1.t("builder.chapter_not_found", 1), node);
            return false;
        }
        var text = i18n_1.t("builder.list", chapter.fqn, node.no);
        process.out(text).out("　");
        return function (v) {
            // name はパスしたい, langもパスしたい
            walker_1.visit(node.args[1], v);
            process.outRaw("\n\n");
            node.childNodes.forEach(function (node) {
                walker_1.visit(node, v);
            });
        };
    };
    TextBuilder.prototype.block_list_post = function (process, _node) {
        process.out("\n◆→終了:リスト←◆\n");
    };
    TextBuilder.prototype.block_listnum_pre = function (process, node) {
        process.out("◆→開始:リスト←◆\n");
        var chapter = utils_1.findChapter(node, 1);
        if (!chapter) {
            process.error(i18n_1.t("builder.chapter_not_found", 1), node);
            return false;
        }
        var text = i18n_1.t("builder.list", chapter.fqn, node.no);
        process.out(text).out("　");
        var lineCount = 1;
        return function (v) {
            // name はパスしたい, langもパスしたい
            walker_1.visit(node.args[1], v);
            var lineCountMax = 0;
            node.childNodes.forEach(function (node, _index, _childNodes) {
                if (node.isTextNode()) {
                    lineCountMax += node.toTextNode().text.split("\n").length;
                }
            });
            var lineDigit = Math.max(utils_1.linesToFigure(lineCountMax), 2);
            process.outRaw("\n\n");
            node.childNodes.forEach(function (node, index, childNodes) {
                if (node.isTextNode()) {
                    // 改行する可能性があるのはTextNodeだけ…のはず
                    var hasNext_1 = !!childNodes[index + 1];
                    var textNode = node.toTextNode();
                    var lines_1 = textNode.text.split("\n");
                    lines_1.forEach(function (line, index) {
                        process.out(utils_1.padLeft(String(lineCount), " ", lineDigit)).out(": ");
                        process.out(line);
                        if (!hasNext_1 || lines_1.length - 1 !== index) {
                            lineCount++;
                        }
                        process.out("\n");
                    });
                }
                else {
                    walker_1.visit(node, v);
                }
            });
        };
    };
    TextBuilder.prototype.block_listnum_post = function (process, _node) {
        process.out("◆→終了:リスト←◆\n");
    };
    TextBuilder.prototype.inline_list = function (process, node) {
        var chapter = utils_1.findChapter(node, 1);
        if (!chapter) {
            process.error(i18n_1.t("builder.chapter_not_found", 1), node);
            return false;
        }
        var listNode = this.findReference(process, node).referenceTo.referenceNode.toBlockElement();
        var text = i18n_1.t("builder.list", chapter.fqn, listNode.no);
        process.out(text);
        return false;
    };
    TextBuilder.prototype.block_emlist_pre = function (process, node) {
        process.out("◆→開始:インラインリスト←◆\n");
        return function (v) {
            // name はパスしたい
            if (node.args[0]) {
                process.out("■");
                walker_1.visit(node.args[0], v);
                process.out("\n");
            }
            node.childNodes.forEach(function (node) {
                walker_1.visit(node, v);
            });
        };
    };
    TextBuilder.prototype.block_emlist_post = function (process, _node) {
        process.out("\n◆→終了:インラインリスト←◆\n");
    };
    TextBuilder.prototype.block_emlistnum_pre = function (process, node) {
        process.out("◆→開始:インラインリスト←◆\n");
        var lineCount = 1;
        return function (v) {
            // name はパスしたい
            if (node.args[0]) {
                process.out("■");
                walker_1.visit(node.args[0], v);
                process.out("\n");
            }
            var lineCountMax = 0;
            node.childNodes.forEach(function (node, _index, _childNodes) {
                if (node.isTextNode()) {
                    lineCountMax += node.toTextNode().text.split("\n").length;
                }
            });
            var lineDigit = Math.max(utils_1.linesToFigure(lineCountMax), 2);
            node.childNodes.forEach(function (node, index, childNodes) {
                if (node.isTextNode()) {
                    // 改行する可能性があるのはTextNodeだけ…のはず
                    var hasNext_2 = !!childNodes[index + 1];
                    var textNode = node.toTextNode();
                    var lines_2 = textNode.text.split("\n");
                    lines_2.forEach(function (line, index) {
                        process.out(utils_1.padLeft(String(lineCount), " ", lineDigit)).out(": ");
                        process.out(line);
                        if (!hasNext_2 || lines_2.length - 1 !== index) {
                            lineCount++;
                        }
                        process.out("\n");
                    });
                }
                else {
                    walker_1.visit(node, v);
                }
            });
        };
    };
    TextBuilder.prototype.block_emlistnum_post = function (process, _node) {
        process.out("◆→終了:インラインリスト←◆\n");
    };
    TextBuilder.prototype.inline_hd_pre = function (process, node) {
        process.out("「");
        var chapter = utils_1.findChapter(node);
        if (!chapter) {
            process.error(i18n_1.t("builder.chapter_not_found", 1), node);
            return false;
        }
        if (chapter.level === 1) {
            process.out(chapter.fqn).out("章 ");
        }
        else {
            process.out(chapter.fqn).out(" ");
        }
        process.out(utils_1.nodeContentToString(process, chapter.headline));
        return false;
    };
    TextBuilder.prototype.inline_hd_post = function (process, _node) {
        process.out("」");
    };
    TextBuilder.prototype.inline_br = function (process, _node) {
        process.out("\n");
    };
    TextBuilder.prototype.inline_b_pre = function (process, _node) {
        process.out("★");
    };
    TextBuilder.prototype.inline_b_post = function (process, _node) {
        process.out("☆");
    };
    TextBuilder.prototype.inline_code_pre = function (process, _node) {
        process.out("△");
    };
    TextBuilder.prototype.inline_code_post = function (process, _node) {
        process.out("☆");
    };
    TextBuilder.prototype.inline_href_pre = function (process, _node) {
        process.out("△");
    };
    TextBuilder.prototype.inline_href_post = function (process, _node) {
        process.out("☆");
    };
    TextBuilder.prototype.inline_href = function (process, node) {
        var href = null;
        var text = utils_1.nodeContentToString(process, node);
        if (text.indexOf(",") !== -1) {
            href = text.slice(0, text.indexOf(","));
            text = text.slice(text.indexOf(",") + 1).trimLeft();
        }
        if (href) {
            process.out(text).out("（△").out(href).out("☆）");
        }
        else {
            process.out("△").out(text).out("☆");
        }
        return false;
    };
    TextBuilder.prototype.block_label = function (_process, _node) {
        return false;
    };
    TextBuilder.prototype.inline_ruby = function (process, node) {
        var contentString = utils_1.nodeContentToString(process, node);
        var keywordData = contentString.split(",");
        process.out(keywordData[0]);
        return function (_v) {
            // name, args はパス
            node.childNodes.forEach(function (_node) {
                process.out("◆→DTP連絡:「").out(keywordData[0]);
                process.out("」に「 ").out(keywordData[1].trim()).out("」とルビ←◆");
            });
        };
    };
    TextBuilder.prototype.inline_u_pre = function (process, _node) {
        process.out("＠");
    };
    TextBuilder.prototype.inline_u_post = function (process, _node) {
        process.out("＠◆→＠〜＠部分に下線←◆");
    };
    TextBuilder.prototype.inline_kw = function (process, node) {
        process.out("★");
        return function (_v) {
            // name, args はパス
            node.childNodes.forEach(function (node) {
                var contentString = utils_1.nodeContentToString(process, node);
                var keywordData = contentString.split(",");
                var pre = keywordData[0];
                var post = (keywordData[1] || "").trimLeft();
                process.out(pre + "\u2606");
                if (post) {
                    process.out("\uFF08" + post + "\uFF09");
                }
            });
        };
    };
    TextBuilder.prototype.inline_tt_pre = function (process, _node) {
        process.out("△");
    };
    TextBuilder.prototype.inline_tt_post = function (process, _node) {
        process.out("☆");
    };
    TextBuilder.prototype.inline_em_pre = function (process, node) {
        process.warn(i18n_1.t("compile.deprecated_inline_symbol", "em"), node);
        process.out("@<em>{");
    };
    TextBuilder.prototype.inline_em_post = function (process, _node) {
        process.out("}");
    };
    TextBuilder.prototype.block_image = function (process, node) {
        var label = utils_1.nodeContentToString(process, node.args[0]);
        return process.findImageFile(label)
            .then(function (imagePath) {
            var caption = utils_1.nodeContentToString(process, node.args[1]);
            process.out("◆→開始:図←◆\n");
            process.out("図").out(process.base.chapter.no).out(".").out(node.no).out("　").out(caption).out("\n");
            process.out("\n");
            process.out("◆→").out(imagePath).out("←◆\n");
            process.out("◆→終了:図←◆\n");
            return false;
        })
            .catch(function (id) {
            process.error(i18n_1.t("builder.image_not_found", id), node);
            return false;
        });
    };
    TextBuilder.prototype.block_indepimage = function (process, node) {
        process.out("◆→画像 ").out(utils_1.nodeContentToString(process, node.args[0])).out("←◆\n");
        if (node.args[1]) {
            process.out("図　").out(utils_1.nodeContentToString(process, node.args[1])).out("\n\n");
        }
        return false;
    };
    TextBuilder.prototype.block_graph_pre = function (process, node) {
        // TODO 以下はとりあえず正規のRe:VIEW文書が食えるようにするための仮実装
        process.outRaw("◆→開始:図←◆\n");
        var toolName = utils_1.nodeContentToString(process, node.args[1]);
        process.outRaw("graph: ").out(toolName).outRaw("</p>\n");
        return function (v) {
            // name, args はパスしたい
            node.childNodes.forEach(function (node) {
                walker_1.visit(node, v);
            });
        };
    };
    TextBuilder.prototype.block_graph_post = function (process, _node) {
        // TODO 以下はとりあえず正規のRe:VIEW文書が食えるようにするための仮実装
        process.outRaw("◆→終了:図←◆\n");
    };
    TextBuilder.prototype.inline_img = function (process, node) {
        var imgNode = this.findReference(process, node).referenceTo.referenceNode.toBlockElement();
        process.out("図").out(process.base.chapter.no).out(".").out(imgNode.no).out("\n");
        return false;
    };
    TextBuilder.prototype.inline_icon = function (process, node) {
        // TODO ファイル名探索ロジックをもっと頑張る(jpgとかsvgとか)
        var chapterFileName = process.base.chapter.name;
        var chapterName = chapterFileName.substring(0, chapterFileName.length - 3);
        var imageName = utils_1.nodeContentToString(process, node);
        var imagePath = "images/" + chapterName + "-" + imageName + ".png";
        process.out("◆→画像 ").out(imagePath).out("←◆");
        return false;
    };
    TextBuilder.prototype.block_footnote = function (process, node) {
        process.out("【注").out(node.no).out("】");
        return function (v) {
            walker_1.visit(node.args[1], v);
            process.out("\n");
        };
    };
    TextBuilder.prototype.inline_fn = function (process, node) {
        var footnoteNode = this.findReference(process, node).referenceTo.referenceNode.toBlockElement();
        process.out("【注").out(footnoteNode.no).out("】");
        return false;
    };
    TextBuilder.prototype.block_lead_pre = function (process, _node) {
        process.out("◆→開始:リード←◆\n");
    };
    TextBuilder.prototype.block_lead_post = function (process, _node) {
        process.out("◆→終了:リード←◆\n");
    };
    TextBuilder.prototype.inline_tti_pre = function (process, _node) {
        process.out("▲");
    };
    TextBuilder.prototype.inline_tti_post = function (process, _node) {
        process.out("☆◆→等幅フォントイタ←◆");
    };
    TextBuilder.prototype.inline_ttb_pre = function (process, _node) {
        process.out("★");
    };
    TextBuilder.prototype.inline_ttb_post = function (process, _node) {
        process.out("☆◆→等幅フォント太字←◆");
    };
    TextBuilder.prototype.block_noindent = function (process, _node) {
        process.out("◆→DTP連絡:次の1行インデントなし←◆\n");
        return false;
    };
    TextBuilder.prototype.block_source_pre = function (process, node) {
        process.out("◆→開始:ソースコードリスト←◆\n");
        process.out("■").out(utils_1.nodeContentToString(process, node.args[0])).out("\n");
        return function (v) {
            // name, args はパスしたい
            node.childNodes.forEach(function (node) {
                walker_1.visit(node, v);
            });
        };
    };
    TextBuilder.prototype.block_source_post = function (process, _node) {
        process.out("\n◆→終了:ソースコードリスト←◆\n");
    };
    TextBuilder.prototype.block_cmd_pre = function (process, node) {
        process.out("◆→開始:コマンド←◆\n");
        return function (v) {
            // name, args はパスしたい
            node.childNodes.forEach(function (node) {
                walker_1.visit(node, v);
            });
        };
    };
    TextBuilder.prototype.block_cmd_post = function (process, _node) {
        process.out("\n◆→終了:コマンド←◆\n");
    };
    TextBuilder.prototype.block_quote_pre = function (process, node) {
        process.out("◆→開始:引用←◆\n");
        return function (v) {
            // name, args はパスしたい
            node.childNodes.forEach(function (node) {
                walker_1.visit(node, v);
            });
        };
    };
    TextBuilder.prototype.block_quote_post = function (process, _node) {
        process.out("\n◆→終了:引用←◆\n");
    };
    TextBuilder.prototype.inline_ami_pre = function (_process, _node) {
    };
    TextBuilder.prototype.inline_ami_post = function (process, node) {
        // TODO 入れ子になっている場合オペレータさんにイミフな出力になっちゃう
        process.out("◆→DTP連絡:「").out(utils_1.nodeContentToString(process, node)).out("」に網カケ←◆");
    };
    TextBuilder.prototype.inline_bou_pre = function (_process, _node) {
    };
    TextBuilder.prototype.inline_bou_post = function (process, node) {
        // TODO 入れ子になっている場合オペレータさんにイミフな出力になっちゃう
        process.out("◆→DTP連絡:「").out(utils_1.nodeContentToString(process, node)).out("」に傍点←◆");
    };
    TextBuilder.prototype.inline_i_pre = function (process, _node) {
        process.out("▲");
    };
    TextBuilder.prototype.inline_i_post = function (process, _node) {
        process.out("☆");
    };
    TextBuilder.prototype.inline_m_pre = function (process, _node) {
        // TODO
        process.outRaw("TODO: ");
    };
    TextBuilder.prototype.inline_m_post = function (process, _node) {
        process.outRaw("");
    };
    TextBuilder.prototype.inline_strong_pre = function (process, _node) {
        process.out("★");
    };
    TextBuilder.prototype.inline_strong_post = function (process, _node) {
        process.out("☆");
    };
    TextBuilder.prototype.inline_uchar = function (process, node) {
        var hexString = utils_1.nodeContentToString(process, node);
        var code = parseInt(hexString, 16);
        var result = "";
        /* tslint:disable:no-bitwise */
        while (code !== 0) {
            result = String.fromCharCode(code & 0xFFFF) + result;
            code >>>= 16;
        }
        /* tslint:enable:no-bitwise */
        process.out(result);
        return false;
    };
    TextBuilder.prototype.block_table_pre = function (process, node) {
        // TODO 以下はとりあえず正規のRe:VIEW文書が食えるようにするための仮実装
        process.out("◆→開始:表←◆\n");
        process.out("TODO 現在table記法は仮実装です\n");
        var chapter = utils_1.findChapter(node, 1);
        if (!chapter) {
            process.error(i18n_1.t("builder.chapter_not_found", 1), node);
            return false;
        }
        var text = i18n_1.t("builder.table", chapter.fqn, node.no);
        process.out(text).out("　").out(utils_1.nodeContentToString(process, node.args[1])).out("\n\n");
        return function (v) {
            // name, args はパスしたい
            node.childNodes.forEach(function (node) {
                walker_1.visit(node, v);
            });
        };
    };
    TextBuilder.prototype.block_table_post = function (process, _node) {
        // TODO 以下はとりあえず正規のRe:VIEW文書が食えるようにするための仮実装
        process.out("\n◆→終了:表←◆\n");
    };
    TextBuilder.prototype.inline_table = function (process, node) {
        // TODO 以下はとりあえず正規のRe:VIEW文書が食えるようにするための仮実装
        var chapter = utils_1.findChapter(node, 1);
        if (!chapter) {
            process.error(i18n_1.t("builder.chapter_not_found", 1), node);
            return false;
        }
        var listNode = this.findReference(process, node).referenceTo.referenceNode.toBlockElement();
        var text = i18n_1.t("builder.table", chapter.fqn, listNode.no);
        process.out(text);
        return false;
    };
    TextBuilder.prototype.block_tsize = function (_process, _node) {
        // TODO 以下はとりあえず正規のRe:VIEW文書が食えるようにするための仮実装
        return false;
    };
    TextBuilder.prototype.block_comment_pre = function (process, node) {
        process.out("◆→DTP連絡:");
        return function (v) {
            // name, args はパスしたい
            node.childNodes.forEach(function (node) {
                walker_1.visit(node, v);
            });
        };
    };
    TextBuilder.prototype.block_comment_post = function (process, _node) {
        process.out("←◆\n");
    };
    TextBuilder.prototype.inline_comment_pre = function (process, _node) {
        process.out("◆→DTP連絡:");
    };
    TextBuilder.prototype.inline_comment_post = function (process, _node) {
        process.out("←◆");
    };
    TextBuilder.prototype.inline_chap = function (process, node) {
        var chapName = utils_1.nodeContentToString(process, node);
        var chapter = process.findChapter(chapName);
        process.out("第").out(chapter.no).out("章");
        return false;
    };
    TextBuilder.prototype.inline_title = function (process, node) {
        var chapName = utils_1.nodeContentToString(process, node);
        var chapter = process.findChapter(chapName);
        var title = this.getChapterTitle(process, chapter);
        process.out(title);
        return false;
    };
    TextBuilder.prototype.inline_chapref = function (process, node) {
        var chapName = utils_1.nodeContentToString(process, node);
        var chapter = process.findChapter(chapName);
        var title = this.getChapterTitle(process, chapter);
        process.out("第").out(chapter.no).out("章「").out(title).out("」");
        return false;
    };
    return TextBuilder;
}(builder_1.DefaultBuilder));
exports.TextBuilder = TextBuilder;
//# sourceMappingURL=textBuilder.js.map