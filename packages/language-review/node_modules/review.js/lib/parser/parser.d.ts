/// <reference types="node" />
/**
 * 文字列をReVIEW文書として解釈し構文木を返す。
 * 解釈に失敗した場合、PEG.SyntaxError または ReVIEW.ParseError が投げられる。
 * @param input
 * @returns {{ast: NodeSyntaxTree, cst: *}}
 */
export declare function parse(input: string): {
    ast: NodeSyntaxTree;
    cst: ConcreatSyntaxTree;
};
/**
 * 具象構文木を抽象構文木に変換します。
 * @param rawResult
 * @returns {*}
 */
export declare function transform(rawResult: ConcreatSyntaxTree): SyntaxTree | null;
/**
 * 構文解析時に発生したエラー。
 */
export declare class ParseError implements Error {
    syntax: ConcreatSyntaxTree;
    message: string;
    name: string;
    constructor(syntax: ConcreatSyntaxTree, message: string);
}
export interface Location {
    start: {
        line: number;
        column: number;
        offset: number;
    };
    end?: {
        line?: number;
        column?: number;
        offset?: number;
    };
}
/**
 * 構文解析直後の生データ。
 */
export interface ConcreatSyntaxTree {
    syntax: string;
    location: Location;
    comments?: any;
    headline?: any;
    text?: any;
    level?: number;
    label?: any;
    cmd?: any;
    caption?: any;
    symbol?: any;
    args?: any;
    content?: any;
    contents?: any;
    arg?: any;
    no?: any;
}
/**
 * 構文解析時のルール名。
 */
export declare enum RuleName {
    SyntaxError = 0,
    Start = 1,
    Chapters = 2,
    Chapter = 3,
    Headline = 4,
    Contents = 5,
    Content = 6,
    Paragraph = 7,
    ParagraphSubs = 8,
    ParagraphSub = 9,
    ContentText = 10,
    BlockElement = 11,
    InlineElement = 12,
    BracketArg = 13,
    BracketArgSubs = 14,
    BracketArgSub = 15,
    BracketArgText = 16,
    BraceArg = 17,
    BlockElementContents = 18,
    BlockElementContent = 19,
    BlockElementParagraph = 20,
    BlockElementParagraphSubs = 21,
    BlockElementParagraphSub = 22,
    BlockElementContentText = 23,
    InlineElementContents = 24,
    InlineElementContent = 25,
    InlineElementContentText = 26,
    SinglelineContent = 27,
    ContentInlines = 28,
    ContentInline = 29,
    ContentInlineText = 30,
    Ulist = 31,
    UlistElement = 32,
    Olist = 33,
    OlistElement = 34,
    Dlist = 35,
    DlistElement = 36,
    DlistElementContents = 37,
    DlistElementContent = 38,
    Column = 39,
    ColumnHeadline = 40,
    ColumnContents = 41,
    ColumnContent = 42,
    ColumnTerminator = 43,
    SinglelineComments = 44,
    SinglelineComment = 45,
}
export interface NodeLocation {
    location: Location;
}
/**
 * 構文解析後の少し加工したデータ。
 */
export declare class SyntaxTree implements NodeLocation {
    parentNode: SyntaxTree;
    location: Location;
    ruleName: RuleName;
    no: number;
    prev: SyntaxTree;
    next: SyntaxTree;
    constructor(data: ConcreatSyntaxTree);
    toJSON(): any;
    toString(indentLevel?: number): string;
    makeIndent(indentLevel: number): string;
    toStringHook(_indentLevel: number, _result: string): void;
    /**
     * 引数が数字かどうかチェックして違うならば例外を投げる。
     * @param value
     * @returns {*=}
     */
    checkNumber(value: any): number;
    /**
     * 引数が文字列かどうかチェックして違うならば例外を投げる。
     * @param value
     * @returns {*=}
     */
    checkString(value: any): string;
    /**
     * 引数がオブジェクトかどうかチェックして違うならば例外を投げる。
     * @param value
     * @returns {*=}
     */
    checkObject(value: any): any;
    /**
     * 引数がArrayかどうかチェックして違うならば例外を投げる。
     * @param value
     * @returns {*=}
     */
    checkArray(value: any): any[];
    private checkSyntaxType(clazz);
    isNode(): boolean;
    isBlockElement(): boolean;
    isInlineElement(): boolean;
    isArgument(): boolean;
    isChapter(): boolean;
    isHeadline(): boolean;
    isUlist(): boolean;
    isOlist(): boolean;
    isDlist(): boolean;
    isTextNode(): boolean;
    isSingleLineComment(): boolean;
    private toOtherNode<T>(clazz);
    /**
     * thisをNodeSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toNode(): NodeSyntaxTree;
    /**
     * thisをBlockElementSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toBlockElement(): BlockElementSyntaxTree;
    /**
     * thisをInlineElementSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toInlineElement(): InlineElementSyntaxTree;
    /**
     * thisをArgumentSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toArgument(): ArgumentSyntaxTree;
    /**
     * thisをChapterSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toChapter(): ChapterSyntaxTree;
    /**
     * thisをColumnSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toColumn(): ColumnSyntaxTree;
    /**
     * thisをHeadlineSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toHeadline(): HeadlineSyntaxTree;
    /**
     * thisをColumnHeadlineSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toColumnHeadline(): ColumnHeadlineSyntaxTree;
    /**
     * thisをUlistElementSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toUlist(): UlistElementSyntaxTree;
    /**
     * thisをOlistElementSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toOlist(): OlistElementSyntaxTree;
    /**
     * thisをDlistElementSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toDlist(): DlistElementSyntaxTree;
    /**
     * thisをTextNodeSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toTextNode(): TextNodeSyntaxTree;
    /**
     * thisをSingleLineCommentSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    toSingleLineCommentNode(): SingleLineCommentSyntaxTree;
}
export declare class NodeSyntaxTree extends SyntaxTree {
    childNodes: SyntaxTree[];
    constructor(data: ConcreatSyntaxTree);
    private processChildNodes(content);
    toStringHook(indentLevel: number, result: string): void;
}
export declare class ChapterSyntaxTree extends NodeSyntaxTree {
    comments: SingleLineCommentSyntaxTree[];
    headline: HeadlineSyntaxTree;
    text: SyntaxTree[];
    constructor(data: ConcreatSyntaxTree);
    readonly level: number;
    readonly fqn: string;
}
export declare class HeadlineSyntaxTree extends SyntaxTree {
    level: number;
    label: ArgumentSyntaxTree;
    caption: NodeSyntaxTree;
    constructor(data: ConcreatSyntaxTree);
}
export declare class BlockElementSyntaxTree extends NodeSyntaxTree {
    symbol: string;
    args: NodeSyntaxTree[];
    constructor(data: ConcreatSyntaxTree);
}
export declare class InlineElementSyntaxTree extends NodeSyntaxTree {
    symbol: string;
    constructor(data: ConcreatSyntaxTree);
}
export declare class ColumnSyntaxTree extends NodeSyntaxTree {
    headline: ColumnHeadlineSyntaxTree;
    text: SyntaxTree[];
    constructor(data: ConcreatSyntaxTree);
    readonly level: number;
    readonly fqn: string;
}
export declare class ColumnHeadlineSyntaxTree extends SyntaxTree {
    level: number;
    caption: NodeSyntaxTree;
    constructor(data: ConcreatSyntaxTree);
}
export declare class ArgumentSyntaxTree extends SyntaxTree {
    arg: string;
    constructor(data: ConcreatSyntaxTree);
}
export declare class UlistElementSyntaxTree extends NodeSyntaxTree {
    level: number;
    text: SyntaxTree;
    constructor(data: ConcreatSyntaxTree);
}
export declare class OlistElementSyntaxTree extends SyntaxTree {
    no: number;
    text: SyntaxTree;
    constructor(data: ConcreatSyntaxTree);
}
export declare class DlistElementSyntaxTree extends SyntaxTree {
    text: SyntaxTree;
    content: SyntaxTree;
    constructor(data: ConcreatSyntaxTree);
}
export declare class TextNodeSyntaxTree extends SyntaxTree {
    text: string;
    constructor(data: ConcreatSyntaxTree);
}
export declare class SingleLineCommentSyntaxTree extends SyntaxTree {
    text: string;
    constructor(data: ConcreatSyntaxTree);
}
