/**
 * 構文解析用途のモジュール。
 */
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var PEG = require("../../resources/grammar");
var walker_1 = require("./walker");
/**
 * 文字列をReVIEW文書として解釈し構文木を返す。
 * 解釈に失敗した場合、PEG.SyntaxError または ReVIEW.ParseError が投げられる。
 * @param input
 * @returns {{ast: NodeSyntaxTree, cst: *}}
 */
function parse(input) {
    "use strict";
    var rawResult = PEG.parse(input);
    var root = transform(rawResult).toNode();
    // ParagraphSubs は構文上の都合であるだけのものなので潰す
    walker_1.visit(root, {
        visitDefaultPre: function (_ast) {
        },
        visitParagraphPre: function (ast) {
            var subs = ast.childNodes[0].toNode();
            ast.childNodes = subs.childNodes;
        }
    });
    // Chapter を Headline の level に応じて構造を組み替える
    //   level 2 は level 1 の下に来るようにしたい
    if (root.childNodes.length !== 0) {
        reconstruct(root.childNodes[0].toNode(), function (chapter) { return chapter.headline.level; });
    }
    // Ulist もChapter 同様の level 構造があるので同じように処理したい
    var ulistSet = [];
    walker_1.visit(root, {
        visitDefaultPre: function (ast) {
            if (ast.ruleName === RuleName.Ulist) {
                ulistSet.push(ast.toNode());
            }
        }
    });
    ulistSet.forEach(function (ulist) {
        reconstruct(ulist, function (ulistElement) { return ulistElement.level; });
    });
    // parentNode を設定
    walker_1.visit(root, {
        visitDefaultPre: function (ast, parent) {
            ast.parentNode = parent;
        }
    });
    // prev, next を設定
    walker_1.visit(root, {
        visitDefaultPre: function (_ast, _parent) {
        },
        visitChapterPre: function (ast) {
            ast.text.forEach(function (node, i, nodes) {
                node.prev = nodes[i - 1];
                node.next = nodes[i + 1];
            });
        },
        visitColumnPre: function (ast) {
            ast.text.forEach(function (node, i, nodes) {
                node.prev = nodes[i - 1];
                node.next = nodes[i + 1];
            });
        },
        visitNodePre: function (ast) {
            ast.childNodes.forEach(function (node, i, nodes) {
                node.prev = nodes[i - 1];
                node.next = nodes[i + 1];
            });
        }
    });
    return {
        ast: root,
        cst: rawResult
    };
}
exports.parse = parse;
/**
 * 具象構文木を抽象構文木に変換します。
 * @param rawResult
 * @returns {*}
 */
function transform(rawResult) {
    "use strict";
    if (!rawResult) {
        return null;
    }
    var rule = RuleName[rawResult.syntax];
    if (typeof rule === "undefined") {
        throw new ParseError(rawResult, "unknown rule: " + rawResult.syntax);
    }
    switch (rule) {
        case RuleName.Chapter:
            return new ChapterSyntaxTree(rawResult);
        case RuleName.BlockElement:
            return new BlockElementSyntaxTree(rawResult);
        case RuleName.Headline:
            return new HeadlineSyntaxTree(rawResult);
        case RuleName.InlineElement:
            return new InlineElementSyntaxTree(rawResult);
        case RuleName.Column:
            return new ColumnSyntaxTree(rawResult);
        case RuleName.ColumnHeadline:
            return new ColumnHeadlineSyntaxTree(rawResult);
        case RuleName.BraceArg:
            return new ArgumentSyntaxTree(rawResult);
        case RuleName.UlistElement:
            return new UlistElementSyntaxTree(rawResult);
        case RuleName.OlistElement:
            return new OlistElementSyntaxTree(rawResult);
        case RuleName.DlistElement:
            return new DlistElementSyntaxTree(rawResult);
        case RuleName.ContentText:
        case RuleName.BracketArgText:
        case RuleName.BlockElementContentText:
        case RuleName.InlineElementContentText:
        case RuleName.ContentInlineText:
            return new TextNodeSyntaxTree(rawResult);
        case RuleName.SinglelineComment:
            return new SingleLineCommentSyntaxTree(rawResult);
        // c, cc パターン
        case RuleName.Chapters:
        case RuleName.Contents:
        case RuleName.ParagraphSubs:
        case RuleName.BracketArgSubs:
        case RuleName.BlockElementContents:
        case RuleName.BlockElementParagraphSubs:
        case RuleName.InlineElementContents:
        case RuleName.ColumnContents:
        case RuleName.ContentInlines:
        case RuleName.Ulist:
        case RuleName.Olist:
        case RuleName.Dlist:
        case RuleName.DlistElementContents:
        case RuleName.SinglelineComments:
            return new NodeSyntaxTree(rawResult);
        // c パターン
        case RuleName.Start:
        case RuleName.Paragraph:
        case RuleName.BracketArg:
        case RuleName.BlockElementParagraph:
        case RuleName.BlockElementParagraphSub:
        case RuleName.DlistElementContent:
            return new NodeSyntaxTree(rawResult);
        // パースした内容は直接役にたたない c / c / c 系
        case RuleName.Content:
        case RuleName.ParagraphSub:
        case RuleName.BracketArgSub:
        case RuleName.BlockElementContent:
        case RuleName.InlineElementContent:
        case RuleName.ColumnContent:
        case RuleName.SinglelineContent:
        case RuleName.ContentInline:
            return transform(rawResult.content);
        default:
            return new SyntaxTree(rawResult);
    }
}
exports.transform = transform;
/**
 * 構文木の組替えを行う。
 * 主に兄弟ノードを親子ノードに組み替えるために使う。
 * @param node
 * @param pickLevel
 */
function reconstruct(node, pickLevel) {
    "use strict";
    var originalChildNodes = node.childNodes;
    var nodeSets = [];
    var currentSet = {
        parent: null,
        children: []
    };
    originalChildNodes.forEach(function (child) {
        if (child.ruleName === RuleName.SinglelineComment) {
            currentSet.children.push(child);
        }
        else if (!currentSet.parent) {
            currentSet.parent = child;
        }
        else if (pickLevel(currentSet.parent) < pickLevel(child)) {
            currentSet.children.push(child);
        }
        else {
            nodeSets.push(currentSet);
            currentSet = {
                parent: child,
                children: []
            };
        }
    });
    if (currentSet.parent) {
        nodeSets.push(currentSet);
    }
    node.childNodes = [];
    nodeSets.forEach(function (nodes) {
        var parent = nodes.parent;
        if (parent) {
            node.childNodes.push(parent);
            nodes.children.forEach(function (child) {
                parent.childNodes.push(child);
            });
            reconstruct(parent, pickLevel);
        }
    });
}
/**
 * 構文解析時に発生したエラー。
 */
var ParseError = (function () {
    function ParseError(syntax, message) {
        this.syntax = syntax;
        this.message = message;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ParseError);
        }
        this.name = "ParseError";
    }
    return ParseError;
}());
exports.ParseError = ParseError;
/**
 * 構文解析時のルール名。
 */
(function (RuleName) {
    RuleName[RuleName["SyntaxError"] = 0] = "SyntaxError";
    RuleName[RuleName["Start"] = 1] = "Start";
    RuleName[RuleName["Chapters"] = 2] = "Chapters";
    RuleName[RuleName["Chapter"] = 3] = "Chapter";
    RuleName[RuleName["Headline"] = 4] = "Headline";
    RuleName[RuleName["Contents"] = 5] = "Contents";
    RuleName[RuleName["Content"] = 6] = "Content";
    RuleName[RuleName["Paragraph"] = 7] = "Paragraph";
    RuleName[RuleName["ParagraphSubs"] = 8] = "ParagraphSubs";
    RuleName[RuleName["ParagraphSub"] = 9] = "ParagraphSub";
    RuleName[RuleName["ContentText"] = 10] = "ContentText";
    RuleName[RuleName["BlockElement"] = 11] = "BlockElement";
    RuleName[RuleName["InlineElement"] = 12] = "InlineElement";
    RuleName[RuleName["BracketArg"] = 13] = "BracketArg";
    RuleName[RuleName["BracketArgSubs"] = 14] = "BracketArgSubs";
    RuleName[RuleName["BracketArgSub"] = 15] = "BracketArgSub";
    RuleName[RuleName["BracketArgText"] = 16] = "BracketArgText";
    RuleName[RuleName["BraceArg"] = 17] = "BraceArg";
    RuleName[RuleName["BlockElementContents"] = 18] = "BlockElementContents";
    RuleName[RuleName["BlockElementContent"] = 19] = "BlockElementContent";
    RuleName[RuleName["BlockElementParagraph"] = 20] = "BlockElementParagraph";
    RuleName[RuleName["BlockElementParagraphSubs"] = 21] = "BlockElementParagraphSubs";
    RuleName[RuleName["BlockElementParagraphSub"] = 22] = "BlockElementParagraphSub";
    RuleName[RuleName["BlockElementContentText"] = 23] = "BlockElementContentText";
    RuleName[RuleName["InlineElementContents"] = 24] = "InlineElementContents";
    RuleName[RuleName["InlineElementContent"] = 25] = "InlineElementContent";
    RuleName[RuleName["InlineElementContentText"] = 26] = "InlineElementContentText";
    RuleName[RuleName["SinglelineContent"] = 27] = "SinglelineContent";
    RuleName[RuleName["ContentInlines"] = 28] = "ContentInlines";
    RuleName[RuleName["ContentInline"] = 29] = "ContentInline";
    RuleName[RuleName["ContentInlineText"] = 30] = "ContentInlineText";
    RuleName[RuleName["Ulist"] = 31] = "Ulist";
    RuleName[RuleName["UlistElement"] = 32] = "UlistElement";
    RuleName[RuleName["Olist"] = 33] = "Olist";
    RuleName[RuleName["OlistElement"] = 34] = "OlistElement";
    RuleName[RuleName["Dlist"] = 35] = "Dlist";
    RuleName[RuleName["DlistElement"] = 36] = "DlistElement";
    RuleName[RuleName["DlistElementContents"] = 37] = "DlistElementContents";
    RuleName[RuleName["DlistElementContent"] = 38] = "DlistElementContent";
    RuleName[RuleName["Column"] = 39] = "Column";
    RuleName[RuleName["ColumnHeadline"] = 40] = "ColumnHeadline";
    RuleName[RuleName["ColumnContents"] = 41] = "ColumnContents";
    RuleName[RuleName["ColumnContent"] = 42] = "ColumnContent";
    RuleName[RuleName["ColumnTerminator"] = 43] = "ColumnTerminator";
    RuleName[RuleName["SinglelineComments"] = 44] = "SinglelineComments";
    RuleName[RuleName["SinglelineComment"] = 45] = "SinglelineComment";
})(exports.RuleName || (exports.RuleName = {}));
var RuleName = exports.RuleName;
/**
 * 構文解析後の少し加工したデータ。
 */
var SyntaxTree = (function () {
    function SyntaxTree(data) {
        this.ruleName = RuleName[data.syntax];
        if (typeof this.ruleName === "undefined") {
            throw new ParseError(data, "unknown rule: " + data.syntax);
        }
        var end = data.location.end || data.location.start; // SyntaxErrorの時
        this.location = {
            start: {
                line: data.location.start.line,
                column: data.location.start.column,
                offset: data.location.start.offset
            },
            end: {
                line: end.line,
                column: end.column,
                offset: end.offset
            }
        };
    }
    SyntaxTree.prototype.toJSON = function () {
        var _this = this;
        var result = {};
        var lowPriorities = [];
        for (var k in this) {
            if (k === "ruleName") {
                result[k] = RuleName[this.ruleName];
            }
            else if (k === "prev" || k === "next" || k === "parentNode") {
            }
            else if (k === "childNodes") {
                // childNodesが先に来ると見づらいので
                lowPriorities.push((function (k) {
                    return function () {
                        result[k] = _this[k];
                    };
                })(k));
            }
            else if (k === "fqn") {
            }
            else if (typeof this[k] !== "function") {
                result[k] = this[k];
            }
        }
        lowPriorities.forEach(function (fn) { return fn(); });
        return result;
    };
    SyntaxTree.prototype.toString = function (indentLevel) {
        if (indentLevel === void 0) { indentLevel = 0; }
        var result = this.makeIndent(indentLevel) + "SyntaxTree:[\n";
        result += this.makeIndent(indentLevel + 1) + "offset = " + this.location.start.offset + ",\n";
        result += this.makeIndent(indentLevel + 1) + "line=" + this.location.start.line + ",\n";
        result += this.makeIndent(indentLevel + 1) + "column=" + this.location.start.column + ",\n";
        result += this.makeIndent(indentLevel + 1) + "name=" + RuleName[this.ruleName] + ",\n";
        this.toStringHook(indentLevel, result);
        result += this.makeIndent(indentLevel) + "]";
        return result;
    };
    SyntaxTree.prototype.makeIndent = function (indentLevel) {
        var indent = "";
        for (var i = 0; i < indentLevel; i++) {
            indent += "  ";
        }
        return indent;
    };
    SyntaxTree.prototype.toStringHook = function (_indentLevel, _result) {
    };
    /**
     * 引数が数字かどうかチェックして違うならば例外を投げる。
     * @param value
     * @returns {*=}
     */
    SyntaxTree.prototype.checkNumber = function (value) {
        if (typeof value !== "number") {
            throw new Error("number required. actual:" + (typeof value) + ":" + value);
        }
        else {
            return value;
        }
    };
    /**
     * 引数が文字列かどうかチェックして違うならば例外を投げる。
     * @param value
     * @returns {*=}
     */
    SyntaxTree.prototype.checkString = function (value) {
        if (typeof value !== "string") {
            throw new Error("string required. actual:" + (typeof value) + ":" + value);
        }
        else {
            return value;
        }
    };
    /**
     * 引数がオブジェクトかどうかチェックして違うならば例外を投げる。
     * @param value
     * @returns {*=}
     */
    SyntaxTree.prototype.checkObject = function (value) {
        if (typeof value !== "object") {
            throw new Error("object required. actual:" + (typeof value) + ":" + value);
        }
        else {
            return value;
        }
    };
    /**
     * 引数がArrayかどうかチェックして違うならば例外を投げる。
     * @param value
     * @returns {*=}
     */
    SyntaxTree.prototype.checkArray = function (value) {
        if (!Array.isArray(value)) {
            console.log(JSON.stringify(value, null, 2));
            throw new Error("array required. actual:" + (typeof value) + ":" + value);
        }
        else {
            return value;
        }
    };
    SyntaxTree.prototype.checkSyntaxType = function (clazz) {
        return this instanceof clazz;
    };
    SyntaxTree.prototype.isNode = function () {
        return this.checkSyntaxType(NodeSyntaxTree);
    };
    SyntaxTree.prototype.isBlockElement = function () {
        return this.checkSyntaxType(BlockElementSyntaxTree);
    };
    SyntaxTree.prototype.isInlineElement = function () {
        return this.checkSyntaxType(InlineElementSyntaxTree);
    };
    SyntaxTree.prototype.isArgument = function () {
        return this.checkSyntaxType(ArgumentSyntaxTree);
    };
    SyntaxTree.prototype.isChapter = function () {
        return this.checkSyntaxType(ChapterSyntaxTree);
    };
    SyntaxTree.prototype.isHeadline = function () {
        return this.checkSyntaxType(HeadlineSyntaxTree);
    };
    SyntaxTree.prototype.isUlist = function () {
        return this.checkSyntaxType(UlistElementSyntaxTree);
    };
    SyntaxTree.prototype.isOlist = function () {
        return this.checkSyntaxType(OlistElementSyntaxTree);
    };
    SyntaxTree.prototype.isDlist = function () {
        return this.checkSyntaxType(DlistElementSyntaxTree);
    };
    SyntaxTree.prototype.isTextNode = function () {
        return this.checkSyntaxType(TextNodeSyntaxTree);
    };
    SyntaxTree.prototype.isSingleLineComment = function () {
        return this.checkSyntaxType(SingleLineCommentSyntaxTree);
    };
    SyntaxTree.prototype.toOtherNode = function (clazz) {
        if (this instanceof clazz) {
            return this;
        }
        else {
            throw new Error("this node is not " + clazz.name + ", actual " + this.constructor.name);
        }
    };
    /**
     * thisをNodeSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toNode = function () {
        return this.toOtherNode(NodeSyntaxTree);
    };
    /**
     * thisをBlockElementSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toBlockElement = function () {
        return this.toOtherNode(BlockElementSyntaxTree);
    };
    /**
     * thisをInlineElementSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toInlineElement = function () {
        return this.toOtherNode(InlineElementSyntaxTree);
    };
    /**
     * thisをArgumentSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toArgument = function () {
        return this.toOtherNode(ArgumentSyntaxTree);
    };
    /**
     * thisをChapterSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toChapter = function () {
        return this.toOtherNode(ChapterSyntaxTree);
    };
    /**
     * thisをColumnSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toColumn = function () {
        return this.toOtherNode(ColumnSyntaxTree);
    };
    /**
     * thisをHeadlineSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toHeadline = function () {
        return this.toOtherNode(HeadlineSyntaxTree);
    };
    /**
     * thisをColumnHeadlineSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toColumnHeadline = function () {
        return this.toOtherNode(ColumnHeadlineSyntaxTree);
    };
    /**
     * thisをUlistElementSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toUlist = function () {
        return this.toOtherNode(UlistElementSyntaxTree);
    };
    /**
     * thisをOlistElementSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toOlist = function () {
        return this.toOtherNode(OlistElementSyntaxTree);
    };
    /**
     * thisをDlistElementSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toDlist = function () {
        return this.toOtherNode(DlistElementSyntaxTree);
    };
    /**
     * thisをTextNodeSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toTextNode = function () {
        return this.toOtherNode(TextNodeSyntaxTree);
    };
    /**
     * thisをSingleLineCommentSyntaxTreeにcast可能か調べ、可能ならcastして返し、そうでなければ例外を投げる。
     */
    SyntaxTree.prototype.toSingleLineCommentNode = function () {
        return this.toOtherNode(SingleLineCommentSyntaxTree);
    };
    return SyntaxTree;
}());
exports.SyntaxTree = SyntaxTree;
var NodeSyntaxTree = (function (_super) {
    __extends(NodeSyntaxTree, _super);
    function NodeSyntaxTree(data) {
        _super.call(this, data);
        this.childNodes = [];
        this.processChildNodes(data.content);
    }
    NodeSyntaxTree.prototype.processChildNodes = function (content) {
        var _this = this;
        if (Array.isArray(content)) {
            content.forEach(function (rawResult) {
                var tree = transform(rawResult);
                if (tree) {
                    _this.childNodes.push(tree);
                }
            });
        }
        else if (content !== "" && content) {
            (function (rawResult) {
                var tree = transform(rawResult);
                if (tree) {
                    _this.childNodes.push(tree);
                }
            })(content);
        }
    };
    NodeSyntaxTree.prototype.toStringHook = function (indentLevel, result) {
        if (this.childNodes.length !== 0) {
            result += this.makeIndent(indentLevel + 1) + "childNodes[" + this.childNodes.length + "]=[\n";
            this.childNodes.forEach(function (node) {
                result += node.toString(indentLevel + 2);
                result += "\n";
            });
            result += this.makeIndent(indentLevel + 1) + "]\n";
        }
    };
    return NodeSyntaxTree;
}(SyntaxTree));
exports.NodeSyntaxTree = NodeSyntaxTree;
// TODO SyntaxTree と指定されている所についてもっと細かく書けるはず…
var ChapterSyntaxTree = (function (_super) {
    __extends(ChapterSyntaxTree, _super);
    function ChapterSyntaxTree(data) {
        _super.call(this, data);
        if (data.comments && data.comments.content) {
            this.comments = this.checkArray(data.comments.content).map(function (data) {
                return transform(data).toSingleLineCommentNode();
            });
        }
        else {
            this.comments = [];
        }
        this.headline = transform(this.checkObject(data.headline)).toHeadline();
        if (typeof data.text === "string" || data.text === null) {
            this.text = [];
            return;
        }
        this.text = this.checkArray(data.text.content).map(function (data) {
            return transform(data);
        });
        delete this.childNodes; // JSON化した時の属性順制御のため…
        this.childNodes = [];
    }
    Object.defineProperty(ChapterSyntaxTree.prototype, "level", {
        get: function () {
            return this.headline.level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChapterSyntaxTree.prototype, "fqn", {
        get: function () {
            var chapters = [];
            walker_1.walk(this, function (node) {
                if (node instanceof ChapterSyntaxTree) {
                    chapters.unshift(node);
                }
                return node.parentNode;
            });
            var result = chapters.map(function (chapter) {
                return chapter.no;
            }).join(".");
            return result;
        },
        enumerable: true,
        configurable: true
    });
    return ChapterSyntaxTree;
}(NodeSyntaxTree));
exports.ChapterSyntaxTree = ChapterSyntaxTree;
var HeadlineSyntaxTree = (function (_super) {
    __extends(HeadlineSyntaxTree, _super);
    function HeadlineSyntaxTree(data) {
        _super.call(this, data);
        this.level = this.checkNumber(data.level);
        if (data.label) {
            this.label = transform(this.checkObject(data.label)).toArgument();
        }
        this.caption = transform(this.checkObject(data.caption)).toNode();
    }
    return HeadlineSyntaxTree;
}(SyntaxTree));
exports.HeadlineSyntaxTree = HeadlineSyntaxTree;
var BlockElementSyntaxTree = (function (_super) {
    __extends(BlockElementSyntaxTree, _super);
    function BlockElementSyntaxTree(data) {
        _super.call(this, data);
        this.symbol = this.checkString(data.symbol);
        this.args = this.checkArray(data.args).map(function (data) {
            return transform(data).toNode();
        });
    }
    return BlockElementSyntaxTree;
}(NodeSyntaxTree));
exports.BlockElementSyntaxTree = BlockElementSyntaxTree;
var InlineElementSyntaxTree = (function (_super) {
    __extends(InlineElementSyntaxTree, _super);
    function InlineElementSyntaxTree(data) {
        _super.call(this, data);
        this.symbol = this.checkString(data.symbol);
    }
    return InlineElementSyntaxTree;
}(NodeSyntaxTree));
exports.InlineElementSyntaxTree = InlineElementSyntaxTree;
var ColumnSyntaxTree = (function (_super) {
    __extends(ColumnSyntaxTree, _super);
    function ColumnSyntaxTree(data) {
        _super.call(this, data);
        this.headline = transform(this.checkObject(data.headline)).toColumnHeadline();
        if (typeof data.text === "string" || data.text === null) {
            this.text = [];
            return;
        }
        this.text = this.checkArray(data.text.content).map(function (data) {
            return transform(data);
        });
        delete this.childNodes; // JSON化した時の属性順制御のため…
        this.childNodes = [];
    }
    Object.defineProperty(ColumnSyntaxTree.prototype, "level", {
        get: function () {
            return this.headline.level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnSyntaxTree.prototype, "fqn", {
        get: function () {
            var chapters = [];
            walker_1.walk(this, function (node) {
                if (node instanceof ChapterSyntaxTree) {
                    chapters.unshift(node);
                }
                return node.parentNode;
            });
            var result = chapters.map(function (chapter) {
                return chapter.no;
            }).join(".");
            return result;
        },
        enumerable: true,
        configurable: true
    });
    return ColumnSyntaxTree;
}(NodeSyntaxTree));
exports.ColumnSyntaxTree = ColumnSyntaxTree;
var ColumnHeadlineSyntaxTree = (function (_super) {
    __extends(ColumnHeadlineSyntaxTree, _super);
    function ColumnHeadlineSyntaxTree(data) {
        _super.call(this, data);
        this.level = this.checkNumber(data.level);
        this.caption = transform(this.checkObject(data.caption)).toNode();
    }
    return ColumnHeadlineSyntaxTree;
}(SyntaxTree));
exports.ColumnHeadlineSyntaxTree = ColumnHeadlineSyntaxTree;
var ArgumentSyntaxTree = (function (_super) {
    __extends(ArgumentSyntaxTree, _super);
    function ArgumentSyntaxTree(data) {
        _super.call(this, data);
        this.arg = this.checkString(data.arg);
    }
    return ArgumentSyntaxTree;
}(SyntaxTree));
exports.ArgumentSyntaxTree = ArgumentSyntaxTree;
var UlistElementSyntaxTree = (function (_super) {
    __extends(UlistElementSyntaxTree, _super);
    function UlistElementSyntaxTree(data) {
        _super.call(this, data);
        this.level = this.checkNumber(data.level);
        this.text = transform(this.checkObject(data.text));
        delete this.childNodes; // JSON化した時の属性順制御のため…
        this.childNodes = [];
    }
    return UlistElementSyntaxTree;
}(NodeSyntaxTree));
exports.UlistElementSyntaxTree = UlistElementSyntaxTree;
var OlistElementSyntaxTree = (function (_super) {
    __extends(OlistElementSyntaxTree, _super);
    function OlistElementSyntaxTree(data) {
        _super.call(this, data);
        this.no = this.checkNumber(data.no);
        this.text = transform(this.checkObject(data.text));
    }
    return OlistElementSyntaxTree;
}(SyntaxTree));
exports.OlistElementSyntaxTree = OlistElementSyntaxTree;
var DlistElementSyntaxTree = (function (_super) {
    __extends(DlistElementSyntaxTree, _super);
    function DlistElementSyntaxTree(data) {
        _super.call(this, data);
        this.text = transform(this.checkObject(data.text));
        this.content = transform(this.checkObject(data.content));
    }
    return DlistElementSyntaxTree;
}(SyntaxTree));
exports.DlistElementSyntaxTree = DlistElementSyntaxTree;
var TextNodeSyntaxTree = (function (_super) {
    __extends(TextNodeSyntaxTree, _super);
    function TextNodeSyntaxTree(data) {
        _super.call(this, data);
        this.text = this.checkString(data.text).replace(/\n+$/, "");
    }
    return TextNodeSyntaxTree;
}(SyntaxTree));
exports.TextNodeSyntaxTree = TextNodeSyntaxTree;
var SingleLineCommentSyntaxTree = (function (_super) {
    __extends(SingleLineCommentSyntaxTree, _super);
    function SingleLineCommentSyntaxTree(data) {
        _super.call(this, data);
        this.text = this.checkString(data.text).replace(/^#@/, "").replace(/\n+$/, "");
    }
    return SingleLineCommentSyntaxTree;
}(SyntaxTree));
exports.SingleLineCommentSyntaxTree = SingleLineCommentSyntaxTree;
//# sourceMappingURL=parser.js.map