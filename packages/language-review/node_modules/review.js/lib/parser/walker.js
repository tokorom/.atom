"use strict";
var parser_1 = require("./parser");
/**
 * 指定された構文木を歩きまわる。
 * 次にどちらへ歩くかは渡した関数によって決まる。
 * null が返ってくると歩くのを中断する。
 * @param ast
 * @param actor
 */
function walk(ast, actor) {
    "use strict";
    if (!ast) {
        return;
    }
    var next = actor(ast);
    if (next) {
        walk(next, actor);
    }
}
exports.walk = walk;
/**
 * 指定された構文木の全てのノード・リーフを同期的に探索する。
 * 親子であれば親のほうが先に探索され、兄弟であれば兄のほうが先に探索される。
 * つまり、葉に着目すると文章に登場する順番に探索される。
 * @param ast
 * @param v
 */
function visit(ast, v) {
    "use strict";
    _visit(function () { return new SyncTaskPool(); }, ast, v);
}
exports.visit = visit;
/**
 * 指定された構文木の全てのノード・リーフを非同期に探索する。
 * 親子であれば親のほうが先に探索され、兄弟であれば兄のほうが先に探索される。
 * つまり、葉に着目すると文章に登場する順番に探索される。
 * @param ast
 * @param v
 */
function visitAsync(ast, v) {
    "use strict";
    return Promise.resolve(_visit(function () { return new AsyncTaskPool(); }, ast, v));
}
exports.visitAsync = visitAsync;
function _visit(poolGenerator, ast, v) {
    "use strict";
    var newV = {
        visitDefaultPre: v.visitDefaultPre,
        visitDefaultPost: v.visitDefaultPost || (function () {
        }),
        visitBlockElementPre: v.visitBlockElementPre || v.visitNodePre || v.visitDefaultPre,
        visitBlockElementPost: v.visitBlockElementPost || v.visitNodePost || v.visitDefaultPost || (function () {
        }),
        visitInlineElementPre: v.visitInlineElementPre || v.visitNodePre || v.visitDefaultPre,
        visitInlineElementPost: v.visitInlineElementPost || v.visitNodePost || v.visitDefaultPost || (function () {
        }),
        visitNodePre: v.visitNodePre || v.visitDefaultPre,
        visitNodePost: v.visitNodePost || v.visitDefaultPost || (function () {
        }),
        visitArgumentPre: v.visitArgumentPre || v.visitDefaultPre,
        visitArgumentPost: v.visitArgumentPost || v.visitDefaultPost || (function () {
        }),
        visitChapterPre: v.visitChapterPre || v.visitNodePre || v.visitDefaultPre,
        visitChapterPost: v.visitChapterPost || v.visitNodePost || v.visitDefaultPost || (function () {
        }),
        visitParagraphPre: v.visitParagraphPre || v.visitNodePre || v.visitDefaultPre,
        visitParagraphPost: v.visitParagraphPost || v.visitNodePost || (function () {
        }),
        visitHeadlinePre: v.visitHeadlinePre || v.visitDefaultPre,
        visitHeadlinePost: v.visitHeadlinePost || v.visitDefaultPost || (function () {
        }),
        visitUlistPre: v.visitUlistPre || v.visitNodePre || v.visitDefaultPre,
        visitUlistPost: v.visitUlistPost || v.visitNodePost || v.visitDefaultPost || (function () {
        }),
        visitOlistPre: v.visitOlistPre || v.visitDefaultPre,
        visitOlistPost: v.visitOlistPost || v.visitDefaultPost || (function () {
        }),
        visitDlistPre: v.visitDlistPre || v.visitDefaultPre,
        visitDlistPost: v.visitDlistPost || v.visitDefaultPost || (function () {
        }),
        visitColumnPre: v.visitColumnPre || v.visitNodePre || v.visitDefaultPre,
        visitColumnPost: v.visitColumnPost || v.visitNodePost || v.visitDefaultPost || (function () {
        }),
        visitColumnHeadlinePre: v.visitColumnHeadlinePre || v.visitDefaultPre,
        visitColumnHeadlinePost: v.visitColumnHeadlinePost || v.visitDefaultPost || (function () {
        }),
        visitTextPre: v.visitTextPre || v.visitDefaultPre,
        visitTextPost: v.visitTextPost || v.visitDefaultPost || (function () {
        }),
        visitSingleLineCommentPre: v.visitSingleLineCommentPre || v.visitDefaultPre,
        visitSingleLineCommentPost: v.visitSingleLineCommentPost || v.visitDefaultPost || (function () {
        })
    };
    newV.visitDefaultPre = newV.visitDefaultPre.bind(v);
    newV.visitDefaultPost = newV.visitDefaultPost.bind(v);
    newV.visitBlockElementPre = newV.visitBlockElementPre.bind(v);
    newV.visitBlockElementPost = newV.visitBlockElementPost.bind(v);
    newV.visitInlineElementPre = newV.visitInlineElementPre.bind(v);
    newV.visitInlineElementPost = newV.visitInlineElementPost.bind(v);
    newV.visitNodePre = newV.visitNodePre.bind(v);
    newV.visitNodePost = newV.visitNodePost.bind(v);
    newV.visitArgumentPre = newV.visitArgumentPre.bind(v);
    newV.visitArgumentPost = newV.visitArgumentPost.bind(v);
    newV.visitChapterPre = newV.visitChapterPre.bind(v);
    newV.visitChapterPost = newV.visitChapterPost.bind(v);
    newV.visitHeadlinePre = newV.visitHeadlinePre.bind(v);
    newV.visitHeadlinePost = newV.visitHeadlinePost.bind(v);
    newV.visitUlistPre = newV.visitUlistPre.bind(v);
    newV.visitUlistPost = newV.visitUlistPost.bind(v);
    newV.visitOlistPre = newV.visitOlistPre.bind(v);
    newV.visitOlistPost = newV.visitOlistPost.bind(v);
    newV.visitDlistPre = newV.visitDlistPre.bind(v);
    newV.visitDlistPost = newV.visitDlistPost.bind(v);
    newV.visitColumnPre = newV.visitColumnPre.bind(v);
    newV.visitColumnPost = newV.visitColumnPost.bind(v);
    newV.visitColumnHeadlinePre = newV.visitColumnHeadlinePre.bind(v);
    newV.visitColumnHeadlinePost = newV.visitColumnHeadlinePost.bind(v);
    newV.visitTextPre = newV.visitTextPre.bind(v);
    newV.visitTextPost = newV.visitTextPost.bind(v);
    newV.visitSingleLineCommentPre = newV.visitSingleLineCommentPre.bind(v);
    newV.visitSingleLineCommentPost = newV.visitSingleLineCommentPost.bind(v);
    return _visitSub(poolGenerator, null, ast, newV);
}
function _visitSub(poolGenerator, parent, ast, v) {
    "use strict";
    if (ast instanceof parser_1.BlockElementSyntaxTree) {
        var _ast_1 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitBlockElementPre(ast, parent);
            pool.handle(ret, {
                next: function () {
                    _ast_1.args.forEach(function (next) {
                        pool.add(function () { return _visitSub(poolGenerator, ast, next, v); });
                    });
                    _ast_1.childNodes.forEach(function (next) {
                        pool.add(function () { return _visitSub(poolGenerator, ast, next, v); });
                    });
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitBlockElementPost(_ast_1, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.InlineElementSyntaxTree) {
        var _ast_2 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitInlineElementPre(ast, parent);
            pool.handle(ret, {
                next: function () {
                    _ast_2.childNodes.forEach(function (next) {
                        pool.add(function () { return _visitSub(poolGenerator, ast, next, v); });
                    });
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitInlineElementPost(_ast_2, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.ArgumentSyntaxTree) {
        var _ast_3 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitArgumentPre(_ast_3, parent);
            pool.handle(ret, {
                next: function () {
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitArgumentPost(_ast_3, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.ChapterSyntaxTree) {
        var _ast_4 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitChapterPre(_ast_4, parent);
            pool.handle(ret, {
                next: function () {
                    if (_ast_4.comments) {
                        _ast_4.comments.forEach(function (next) {
                            pool.add(function () { return _visitSub(poolGenerator, ast, next, v); });
                        });
                    }
                    pool.add(function () { return _visitSub(poolGenerator, _ast_4, _ast_4.headline, v); });
                    if (_ast_4.text) {
                        _ast_4.text.forEach(function (next) {
                            pool.add(function () { return _visitSub(poolGenerator, ast, next, v); });
                        });
                    }
                    _ast_4.childNodes.forEach(function (next) {
                        pool.add(function () { return _visitSub(poolGenerator, ast, next, v); });
                    });
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitChapterPost(_ast_4, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.HeadlineSyntaxTree) {
        var _ast_5 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitHeadlinePre(ast, parent);
            pool.handle(ret, {
                next: function () {
                    pool.add(function () { return _visitSub(poolGenerator, _ast_5, _ast_5.label, v); });
                    pool.add(function () { return _visitSub(poolGenerator, _ast_5, _ast_5.caption, v); });
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitHeadlinePost(_ast_5, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.ColumnSyntaxTree) {
        var _ast_6 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitColumnPre(_ast_6, parent);
            pool.handle(ret, {
                next: function () {
                    pool.add(function () { return _visitSub(poolGenerator, _ast_6, _ast_6.headline, v); });
                    if (_ast_6.text) {
                        _ast_6.text.forEach(function (next) {
                            pool.add(function () { return _visitSub(poolGenerator, ast, next, v); });
                        });
                    }
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitColumnPost(_ast_6, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.ColumnHeadlineSyntaxTree) {
        var _ast_7 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitColumnHeadlinePre(_ast_7, parent);
            pool.handle(ret, {
                next: function () {
                    pool.add(function () { return _visitSub(poolGenerator, _ast_7, _ast_7.caption, v); });
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitColumnHeadlinePost(_ast_7, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.UlistElementSyntaxTree) {
        var _ast_8 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitUlistPre(ast, parent);
            pool.handle(ret, {
                next: function () {
                    pool.add(function () { return _visitSub(poolGenerator, _ast_8, _ast_8.text, v); });
                    _ast_8.childNodes.forEach(function (next) {
                        pool.add(function () { return _visitSub(poolGenerator, ast, next, v); });
                    });
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitUlistPost(_ast_8, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.OlistElementSyntaxTree) {
        var _ast_9 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitOlistPre(ast, parent);
            pool.handle(ret, {
                next: function () {
                    pool.add(function () { return _visitSub(poolGenerator, _ast_9, _ast_9.text, v); });
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitOlistPost(_ast_9, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.DlistElementSyntaxTree) {
        var _ast_10 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitDlistPre(ast, parent);
            pool.handle(ret, {
                next: function () {
                    pool.add(function () { return _visitSub(poolGenerator, _ast_10, _ast_10.text, v); });
                    pool.add(function () { return _visitSub(poolGenerator, _ast_10, _ast_10.content, v); });
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitDlistPost(_ast_10, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.NodeSyntaxTree && (ast.ruleName === parser_1.RuleName.Paragraph || ast.ruleName === parser_1.RuleName.BlockElementParagraph)) {
        var _ast_11 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitParagraphPre(_ast_11, parent);
            pool.handle(ret, {
                next: function () {
                    _ast_11.childNodes.forEach(function (next) {
                        pool.add(function () { return _visitSub(poolGenerator, _ast_11, next, v); });
                    });
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitParagraphPost(_ast_11, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.NodeSyntaxTree) {
        var _ast_12 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitNodePre(_ast_12, parent);
            pool.handle(ret, {
                next: function () {
                    _ast_12.childNodes.forEach(function (next) {
                        pool.add(function () { return _visitSub(poolGenerator, _ast_12, next, v); });
                    });
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitNodePost(_ast_12, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.TextNodeSyntaxTree) {
        var _ast_13 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitTextPre(_ast_13, parent);
            pool.handle(ret, {
                next: function () {
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitTextPost(_ast_13, parent); });
            return pool.consume();
        })();
    }
    else if (ast instanceof parser_1.SingleLineCommentSyntaxTree) {
        var _ast_14 = ast;
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitSingleLineCommentPre(_ast_14, parent);
            pool.handle(ret, {
                next: function () {
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitSingleLineCommentPost(_ast_14, parent); });
            return pool.consume();
        })();
    }
    else if (ast) {
        return (function () {
            var pool = poolGenerator();
            var ret = v.visitDefaultPre(ast, parent);
            pool.handle(ret, {
                next: function () {
                },
                func: function () {
                    typeof ret === "function" && ret(v);
                }
            });
            pool.add(function () { return v.visitDefaultPost(ast, parent); });
            return pool.consume();
        })();
    }
    else {
        return (function () {
            var pool = poolGenerator();
            return pool.consume();
        })();
    }
}
/**
 * 同期化処理をそのまま同期処理として扱うためのヘルパクラス。
 */
var SyncTaskPool = (function () {
    function SyncTaskPool() {
        this.tasks = [];
    }
    SyncTaskPool.prototype.add = function (value) {
        this.tasks.push(value);
    };
    SyncTaskPool.prototype.handle = function (value, statements) {
        if (typeof value === "undefined" || (typeof value === "boolean" && value)) {
            statements.next();
        }
        else if (typeof value === "function") {
            statements.func();
        }
    };
    SyncTaskPool.prototype.consume = function () {
        return this.tasks.map(function (task) { return task(); });
    };
    return SyncTaskPool;
}());
/**
 * 同期化処理を非同期化するためのヘルパクラス。
 * array.forEach(value => process(value)); を以下のように書き換えて使う。
 * let pool = new AsyncTaskPool<any>();
 * array.forEach(value => pool.add(()=> process(value));
 * pool.consume().then(()=> ...);
 */
var AsyncTaskPool = (function () {
    function AsyncTaskPool() {
        this.tasks = [];
    }
    AsyncTaskPool.prototype.add = function (value) {
        this.tasks.push(function () { return Promise.resolve(value()); });
    };
    AsyncTaskPool.prototype.handle = function (value, statements) {
        if (typeof value === "undefined" || (typeof value === "boolean" && value)) {
            statements.next();
        }
        else if (value && typeof value.then === "function") {
            this.tasks.push(function () { return Promise.resolve(value); });
        }
        else if (typeof value === "function") {
            statements.func();
        }
    };
    AsyncTaskPool.prototype.consume = function () {
        var _this = this;
        var promise = new Promise(function (resolve) {
            var result = [];
            var next = function () {
                var func = _this.tasks.shift();
                if (!func) {
                    resolve(result);
                    return;
                }
                func().then(function (value) {
                    result.push(value);
                    next();
                });
            };
            next();
        });
        return promise;
    };
    return AsyncTaskPool;
}());
//# sourceMappingURL=walker.js.map