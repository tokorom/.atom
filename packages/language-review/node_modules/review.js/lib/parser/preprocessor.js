"use strict";
var parser_1 = require("./parser");
var walker_1 = require("./walker");
var utils_1 = require("../utils/utils");
/**
 * インライン構文やブロック構文中で利用可能な構造について制限をかけ、構文木を組み替える。
 * 種類は主に3種類。
 * 1. テキストをベースとしてインライン構文のみ許可する(デフォルト
 * 2. 全て許可せずテキストとして扱う
 * 3. 全てを許可する(なにもしない
 * AcceptableSyntaxes にしたがって処理する。
 */
var SyntaxPreprocessor = (function () {
    function SyntaxPreprocessor() {
    }
    SyntaxPreprocessor.prototype.start = function (book) {
        var _this = this;
        this.acceptableSyntaxes = book.acceptableSyntaxes;
        book.predef.forEach(function (chunk) { return _this.preprocessChunk(chunk); });
        book.contents.forEach(function (chunk) { return _this.preprocessChunk(chunk); });
        book.appendix.forEach(function (chunk) { return _this.preprocessChunk(chunk); });
        book.postdef.forEach(function (chunk) { return _this.preprocessChunk(chunk); });
    };
    SyntaxPreprocessor.prototype.preprocessChunk = function (chunk) {
        var _this = this;
        walker_1.visit(chunk.tree.ast, {
            visitDefaultPre: function (_node) {
            },
            visitColumnPre: function (node) {
                _this.preprocessColumnSyntax(chunk, node);
            },
            visitBlockElementPre: function (node) {
                _this.preprocessBlockSyntax(chunk, node);
            }
        });
        chunk.nodes.forEach(function (chunk) { return _this.preprocessChunk(chunk); });
    };
    /**
     * コラム記法を組み替える。
     * コラムの中ではHeadlineが使えるが、コラム自体の見出しレベルより深いレベルのHeadlineしか許可されない。
     * そのため、コラム自体より浅いレベルの見出しレベルを見つけたらコラム内から脱出させる。
     * @param chunk
     * @param column
     */
    SyntaxPreprocessor.prototype.preprocessColumnSyntax = function (chunk, column) {
        function reconstruct(parent, target, to) {
            if (to === void 0) { to = column.parentNode.toChapter(); }
            if (target.level <= to.level) {
                reconstruct(parent.parentNode.toNode(), target, to.parentNode.toChapter());
                return;
            }
            // コラムより大きなChapterを見つけた場合、それ以下のノードは全て引き上げる
            to.childNodes.splice(to.childNodes.indexOf(parent) + 1, 0, target);
            column.text.splice(column.text.indexOf(target), 1);
        }
        // 組み換え
        walker_1.visit(column, {
            visitDefaultPre: function (_node) {
            },
            visitColumnPre: function (_node) {
                // TODO ここに来たらエラーにするべき
            },
            visitChapterPre: function (node) {
                if (column.level < node.headline.level) {
                    return;
                }
                reconstruct(column, node);
            }
        });
        // Parser.ts からのコピペなので共通ロジックとしてリファクタリングする
        // parentNode を設定
        walker_1.visit(chunk.tree.ast, {
            visitDefaultPre: function (ast, parent) {
                ast.parentNode = parent;
            }
        });
        // prev, next を設定
        walker_1.visit(chunk.tree.ast, {
            visitDefaultPre: function (_ast, _parent) {
            },
            visitChapterPre: function (ast) {
                ast.text.forEach(function (node, i, nodes) {
                    node.prev = nodes[i - 1];
                    node.next = nodes[i + 1];
                });
            },
            visitColumnPre: function (ast) {
                ast.text.forEach(function (node, i, nodes) {
                    node.prev = nodes[i - 1];
                    node.next = nodes[i + 1];
                });
            },
            visitNodePre: function (ast) {
                ast.childNodes.forEach(function (node, i, nodes) {
                    node.prev = nodes[i - 1];
                    node.next = nodes[i + 1];
                });
            }
        });
    };
    /**
     * ブロック記法の中身を組み替える。
     * ブロック記法は 1. 全ての記法を許可 2. インライン記法のみ許可 3. 全てを許可しない の3パターンの組み換えがある。
     * @param chapter
     * @param node
     */
    SyntaxPreprocessor.prototype.preprocessBlockSyntax = function (chunk, node) {
        if (node.childNodes.length === 0) {
            return;
        }
        var syntaxes = this.acceptableSyntaxes.find(node);
        if (syntaxes.length !== 1) {
            // TODO エラーにしたほうがいいかなぁ
            return;
        }
        var syntax = syntaxes[0];
        if (syntax.allowFullySyntax) {
            // 全て許可
            return;
        }
        else if (syntax.allowInline) {
            // inline構文のみ許可(Paragraphは殺す
            // inline以外の構文は叩き潰してTextにmergeする
            var info_1 = null;
            var resultNodes_1 = [];
            var lastNode_1 = null;
            walker_1.visit(node.childNodes[0], {
                visitDefaultPre: function (node) {
                    if (!info_1) {
                        info_1 = {
                            offset: node.location.start.offset,
                            line: node.location.start.line,
                            column: node.location.start.column
                        };
                    }
                    lastNode_1 = node;
                },
                visitInlineElementPre: function (node) {
                    var textNode = new parser_1.TextNodeSyntaxTree({
                        syntax: "BlockElementContentText",
                        location: {
                            start: {
                                offset: info_1.offset,
                                line: info_1.line,
                                column: info_1.column
                            },
                            end: {
                                offset: node.location.start.offset - 1,
                                line: void 0,
                                column: void 0,
                            }
                        },
                        text: chunk.process.input.substring(info_1.offset, node.location.start.offset - 1)
                    });
                    if (textNode.text) {
                        resultNodes_1.push(textNode);
                    }
                    resultNodes_1.push(textNode);
                    resultNodes_1.push(node);
                    info_1 = null;
                    lastNode_1 = node;
                },
                visitSingleLineCommentPre: function (node) {
                    if (!info_1) {
                        lastNode_1 = node;
                        return;
                    }
                    var textNode = new parser_1.TextNodeSyntaxTree({
                        syntax: "BlockElementContentText",
                        location: {
                            start: {
                                offset: info_1.offset,
                                line: info_1.line,
                                column: info_1.column
                            },
                            end: {
                                offset: node.location.start.offset - 1,
                                line: void 0,
                                column: void 0,
                            }
                        },
                        text: chunk.process.input.substring(info_1.offset, node.location.start.offset - 1)
                    });
                    if (textNode.text) {
                        resultNodes_1.push(textNode);
                    }
                    info_1 = null;
                    lastNode_1 = node;
                }
            });
            if (info_1) {
                var textNode = new parser_1.TextNodeSyntaxTree({
                    syntax: "BlockElementContentText",
                    location: {
                        start: {
                            offset: info_1.offset,
                            line: info_1.line,
                            column: info_1.column,
                        },
                        end: {
                            offset: node.location.start.offset - 1,
                            line: void 0,
                            column: void 0,
                        }
                    },
                    text: chunk.process.input.substring(info_1.offset, lastNode_1.location.end.offset)
                });
                if (textNode.text) {
                    resultNodes_1.push(textNode);
                }
            }
            node.childNodes = resultNodes_1;
        }
        else {
            // 全て不許可(テキスト化
            var first = node.childNodes[0];
            var last = node.childNodes[node.childNodes.length - 1];
            var textNode = new parser_1.TextNodeSyntaxTree({
                syntax: "BlockElementContentText",
                location: {
                    start: {
                        offset: first.location.start.offset,
                        line: first.location.start.line,
                        column: first.location.start.column
                    },
                    end: {
                        offset: last.location.start.offset - 1,
                        line: void 0,
                        column: void 0,
                    }
                },
                text: utils_1.nodeContentToString(chunk.process, node)
            });
            node.childNodes = [textNode];
        }
    };
    return SyntaxPreprocessor;
}());
exports.SyntaxPreprocessor = SyntaxPreprocessor;
//# sourceMappingURL=preprocessor.js.map