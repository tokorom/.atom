"use strict";
var fs = require("fs");
var path = require("path");
var jsyaml = require("js-yaml");
var updateNotifier = require("update-notifier");
var index_1 = require("./index");
var compilerModel_1 = require("./model/compilerModel");
var utils_1 = require("./utils/utils");
/* tslint:disable:no-require-imports */
var pkg = require("../package.json");
/* tslint:enable:no-require-imports */
var notifier = updateNotifier({
    packageName: pkg.name,
    packageVersion: pkg.version
});
if (notifier.update) {
    notifier.notify();
}
var packageJson = JSON.parse(fs.readFileSync(path.resolve(__dirname, "../package.json"), "utf8"));
var commandpost = require("commandpost");
var root = commandpost
    .create("reviewjs")
    .version(packageJson.version, "-v, --version")
    .option("--reviewfile <file>", "where is ReVIEWconfig.js?")
    .option("--base <path>", "alternative base path")
    .action(function () {
    process.stdout.write(root.helpText() + '\n');
});
root
    .subCommand("compile [document]")
    .description("compile ReVIEW document")
    .option("--ast", "output JSON format abstract syntax tree")
    .option("-t, --target <target>", "output format of document")
    .action(function (opts, args) {
    // .action((document:string, options:any)=> {
    var ast = !!opts.ast;
    var target = opts.target[0] || "html";
    return new Promise(function (resolve, reject) {
        var input = "";
        if (args.document) {
            var targetPath = path.resolve(process.cwd(), args.document);
            if (!fs.existsSync(targetPath)) {
                console.error(targetPath + " not exists");
                reject(null);
                return;
            }
            input = fs.readFileSync(targetPath, "utf8");
            resolve({ fileName: args.document, input: input });
        }
        else {
            process.stdin.resume();
            process.stdin.setEncoding("utf8");
            process.stdin.on("data", function (chunk) {
                input += chunk;
            });
            process.stdin.on("end", function () {
                resolve({ fileName: "content.re", input: input });
            });
        }
    })
        .then(function (value) { return utils_1.Exec.singleCompile(value.input, value.fileName, target, null); })
        .then(function (result) {
        if (!result.book.hasError && !ast) {
            result.book.allChunks[0].builderProcesses.forEach(function (process) {
                console.log(process.result);
            });
            return null;
        }
        else if (!result.book.hasError) {
            var jsonString = JSON.stringify(result.book.allChunks[0].tree.ast, null, 2);
            console.log(jsonString);
            return null;
        }
        else {
            result.book.reports.forEach(function (report) {
                var log = function (_msg) { };
                switch (report.level) {
                    case compilerModel_1.ReportLevel.Info:
                        log = process.stdout.write;
                    case compilerModel_1.ReportLevel.Warning:
                        log = process.stderr.write;
                    case compilerModel_1.ReportLevel.Error:
                        log = process.stderr.write;
                }
                var message = "";
                report.nodes.forEach(function (node) {
                    message += "[" + node.location.start.line + ", " + node.location.start.column + "] ";
                });
                message += report.message + "\n";
                log(message);
            });
            return Promise.reject("unexpected error occured");
        }
    });
});
root
    .subCommand("build [target]")
    .description("build book")
    .action(function (_opts, args) {
    // .action((target:string, options:any)=> {
    if (!args.target) {
        console.log("set target to html");
    }
    var target = args.target || "html";
    var reviewfile = root.parsedOpts.reviewfile[0] || "./ReVIEWconfig.js";
    function byReVIEWConfig() {
        /* tslint:disable:no-require-imports */
        var setup = require(path.resolve(process.cwd(), reviewfile));
        /* tslint:enable:no-require-imports */
        return index_1.start(setup, {
            reviewfile: reviewfile,
            base: root.parsedOpts.base[0]
        })
            .then(function (book) {
            console.log("completed!");
            book.reports.forEach(function (report) {
                var log = function (_msg) { };
                switch (report.level) {
                    case compilerModel_1.ReportLevel.Info:
                        log = process.stdout.write;
                    case compilerModel_1.ReportLevel.Warning:
                        log = process.stderr.write;
                    case compilerModel_1.ReportLevel.Error:
                        log = process.stderr.write;
                }
                var message = "";
                report.nodes.forEach(function (node) {
                    message += "[" + node.location.start.line + ", " + node.location.start.column + "] ";
                });
                message += report.message + "\n";
                log(message);
            });
        });
    }
    function byConfigYaml() {
        var catalogYaml = jsyaml.safeLoad(fs.readFileSync(path.resolve(process.cwd(), "catalog.yml"), "utf8"));
        var configRaw = {
            builders: [utils_1.target2builder(target)],
            book: catalogYaml
        };
        return index_1.start(function (review) {
            review.initConfig(configRaw);
        }, {
            reviewfile: reviewfile,
            base: root.parsedOpts.base[0]
        })
            .then(function (book) {
            process.stdout.write("completed!\n");
            book.reports.forEach(function (report) {
                var log = function (_msg) { };
                switch (report.level) {
                    case compilerModel_1.ReportLevel.Info:
                        log = process.stdout.write;
                    case compilerModel_1.ReportLevel.Warning:
                        log = process.stderr.write;
                    case compilerModel_1.ReportLevel.Error:
                        log = process.stderr.write;
                }
                var message = "";
                report.nodes.forEach(function (node) {
                    message += "[" + node.location.start.line + ", " + node.location.start.column + "] ";
                });
                message += report.message + "\n";
                log(message);
            });
        });
    }
    if (fs.existsSync(path.resolve(process.cwd(), reviewfile))) {
        return byReVIEWConfig();
    }
    else if (fs.existsSync(path.resolve(process.cwd(), "config.yml"))) {
        return byConfigYaml();
    }
    else {
        throw new Error("can not found ReVIEWconfig.js or config.yml");
    }
});
commandpost
    .exec(root, process.argv)
    .then(function () {
    process.stdout.write("");
    process.stderr.write("");
    process.exit(0);
}, function (err) {
    console.error("unexpected error", err);
    if (err.stack) {
        console.error(err.stack);
    }
    process.stdout.write("");
    process.stderr.write("");
    process.exit(1);
});
//# sourceMappingURL=cli.js.map